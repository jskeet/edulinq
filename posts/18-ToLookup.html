<html>
<head>
<title>Reimplementing LINQ to Objects: Part 18 - ToLookup</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 18 - ToLookup</h1>
<p>I&#39;ve had a request to implement Join, which seems a perfectly reasonable operator to aim towards. However, it&#39;s going to be an awful lot easier to implement if we write ToLookup first. That will also help with GroupBy and GroupJoin, later on.</p>  <p>In the course of this post we&#39;ll create a certain amount of infrastructure - some of which we may want to tweak later on.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.tolookup.aspx" target="_blank">ToLookup</a> has four overloads, with these signatures:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TSource&gt; ToLookup&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TSource&gt; ToLookup&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer) </div>  <p>Essentially these boil down to two required parameters and two optional ones:</p>  <ul>   <li>The source is required, and must not be null </li>    <li>The keySelector is required, and must not be null </li>    <li>The elementSelector is optional, and defaults to an identity projection of a source element to itself. If it is specified, it must not be null. </li>    <li>The comparer is optional, and defaults to the default equality comparer for the key type. It may be null, which is equivalent to specifying the default equality comparer for the key type. </li> </ul>  <p>Now we can just consider the most general case - the final overload. However, in order to understand what ToLookup does, we have to know what ILookup&lt;TKey, TElement&gt; means - which in turn means knowing about IGrouping&lt;TKey, TElement&gt;:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="ReferenceType">interface</span> IGrouping&lt;<span class="MethodParameter">out</span> TKey, <span class="MethodParameter">out</span> TElement&gt; : IEnumerable&lt;TElement&gt;     <br />{     <br />&#160;&#160;&#160; TKey Key { get; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="ReferenceType">interface</span> ILookup&lt;TKey, TElement&gt; : IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> Count { get; }     <br />&#160;&#160;&#160; IEnumerable&lt;TElement&gt; <span class="Keyword">this</span>[TKey key] { get; }     <br />&#160;&#160;&#160; <span class="ValueType">bool</span> Contains(TKey key);     <br />} </div>  <p>The generics make these interfaces seem somewhat scary at first sight, but they&#39;re really not so bad. A <em>grouping</em> is simply a sequence with an associated key. This is a pretty simple concept to transfer to the real world - something like &quot;Plays by Oscar Wilde&quot; could be an IGrouping&lt;string, Play&gt; with a key of &quot;Oscar Wilde&quot;. The key doesn&#39;t have to be &quot;embedded&quot; within the element type though - it would also be reasonable to have an IGrouping&lt;string, string&gt; representing just the <em>names</em> of plays by Oscar Wilde.</p>  <p>A <em>lookup</em> is essentially a map or dictionary where each key is associated with a sequence of values instead of a single one. Note that the interface is read-only, unlike IDictionary&lt;TKey, TValue&gt;. As well as looking up a single sequence of values associated with a key, you can also iterate over the whole lookup in terms of groupings (instead of the key/value pair from a dictionary). There&#39;s one other important difference between a lookup and a dictionary: if you ask a lookup for the sequence corresponding to a key which it doesn&#39;t know about, it will return an empty sequence, rather than throwing an exception. (A key which the lookup <em>does</em> know about will never yield an empty sequence.)</p>  <p>One slightly odd point to note is that while IGrouping is covariant in TKey and TElement, ILookup is invariant in both of its type parameters. While TKey has to be invariant, it would be reasonable for TElement to be covariant - to go back to our &quot;plays&quot; example, an IGrouping&lt;string, Play&gt; could be sensibly regarded as an IGrouping&lt;string, IWrittenWork&gt; (with the obvious type hierarchy). However, the interface declarations above are the ones in .NET 4, so that&#39;s what I&#39;ve used in Edulinq.</p>  <p>Now that we understand the signature of ToLookup, let&#39;s talk about what it actually does. Firstly, it uses <em>immediate execution</em> - the lookup returned by the method is effectively divorced from the original sequence; changes to the sequence after the method has returned won&#39;t change the lookup. (Obviously changes to the objects <em>within</em> the original sequence may still be seen, depending on what the element selector does, etc.) The rest is actually fairly straightforward, when you consider what parameters we have to play with:</p>  <ul>   <li>The keySelector is applied to each item in the input sequence. Keys are always compared for equality using the &quot;comparer&quot; parameter. </li>    <li>The elementSelector is applied to each item in the input sequence, to project the item to the value which will be returned within the lookup. </li> </ul>  <p>To demonstrate this a little further, here are two applications of ToLookup - one using the first overload, and one using the last. In each case we&#39;re going to group plays by author and then display some information about them. Hopefully this will make some of the concepts I&#39;ve described a little more concrete:</p>  <div class="code">ILookup&lt;<span class="ReferenceType">string</span>, Play&gt; lookup = allPlays.ToLookup(play =&gt; play.Author);     <br /><span class="Statement">foreach</span> (IGrouping&lt;<span class="ReferenceType">string</span>, Play&gt; <span class="Linq">group</span>&#160;<span class="Statement">in</span> lookup)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;Plays by {0}&quot;</span>, <span class="Linq">group</span>.Key);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (Play play <span class="Statement">in</span>&#160;<span class="Linq">group</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;&#160; {0} ({1})&quot;</span>, play.Name, play.CopyrightDate);     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="InlineComment">// Or...</span>     <br />    <br />ILookup&lt;<span class="ReferenceType">string</span>, <span class="ReferenceType">string</span>&gt; lookup = allPlays.ToLookup(play =&gt; play.Author,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; play =&gt; play.Name,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; StringComparer.OrdinalIgnoreCase);     <br /><span class="Statement">foreach</span> (IGrouping&lt;<span class="ReferenceType">string</span>, <span class="ReferenceType">string</span>&gt; <span class="Linq">group</span>&#160;<span class="Statement">in</span> lookup)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;Plays by {0}:&quot;</span>, <span class="Linq">group</span>.Key);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ReferenceType">string</span> playName <span class="Statement">in</span>&#160;<span class="Linq">group</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;&#160; {0}&quot;</span>, playName);     <br />&#160;&#160;&#160; }     <br />}     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="InlineComment">// And demonstrating looking up by a key:</span>     <br />IEnumerable&lt;<span class="ReferenceType">string</span>&gt; playsByWilde = lookup[<span class="String">&quot;Oscar Wilde&quot;</span>];     <br />Console.WriteLine(<span class="String">&quot;Plays by Oscar Wilde: {0}&quot;</span>,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ReferenceType">string</span>.Join(<span class="String">&quot;; &quot;</span>, playsByWilde)); </div>  <p>Note that although I&#39;ve used explicit typing for all the variables here, I would <em>usually</em> use implicit typing with var, just to keep the code more concise.</p>  <p>Now we just have the small matter of working out how to go from a key/element pair for each item, to a data structure which lets us look up sequences by key.</p>  <p>Before we move onto the implementation and tests, there are two aspects of ordering to consider:</p>  <ul>   <li>How are the groups within the lookup ordered? </li>    <li>How are the elements within each group ordered? </li> </ul>  <p>The documentation for ToLookup is silent on these matters - but the <a href="http://msdn.microsoft.com/en-us/library/bb534501.aspx" target="_blank">docs for the closely-related GroupBy operator</a> are more specific:</p>  <blockquote>   <p>The IGrouping&lt;TKey, TElement&gt; objects are yielded in an order based on the order of the elements in source that produced the first key of each IGrouping&lt;TKey, TElement&gt;. Elements in a grouping are yielded in the order they appear in source.</p> </blockquote>  <p>Admittedly &quot;in an order based on...&quot; isn&#39;t as clear as it might be, but I think it&#39;s reasonable to make sure that our implementation yields groups such that the first group returned has the same key as the first element in the source, and so on.</p>  <h3>What are we going to test?</h3>  <p>I&#39;ve actually got relatively few tests this time. I test each of the overloads, but not terribly exhaustively. There are three tests worth looking at though. The first two show the &quot;eager&quot; nature of the operator, and the final one demonstrates the most complex overload by grouping people into families.</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SourceSequenceIsReadEagerly()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> source = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; source.ToLookup(x =&gt; x));     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> ChangesToSourceSequenceAfterToLookupAreNotNoticed()     <br />{     <br />&#160;&#160;&#160; List&lt;<span class="ReferenceType">string</span>&gt; source = <span class="Keyword">new</span> List&lt;<span class="ReferenceType">string</span>&gt; { <span class="String">&quot;abc&quot;</span> };     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = source.ToLookup(x =&gt; x.Length);     <br />&#160;&#160;&#160; Assert.AreEqual(1, lookup.Count);     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Potential new key is ignored</span>     <br />&#160;&#160;&#160; source.Add(<span class="String">&quot;x&quot;</span>);     <br />&#160;&#160;&#160; Assert.AreEqual(1, lookup.Count);     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Potential new value for existing key is ignored</span>     <br />&#160;&#160;&#160; source.Add(<span class="String">&quot;xyz&quot;</span>);     <br />&#160;&#160;&#160; lookup[3].AssertSequenceEqual(<span class="String">&quot;abc&quot;</span>);     <br />}     <br />    <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> LookupWithComparareAndElementSelector()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> people = <span class="Keyword">new</span>[] {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Jon&quot;</span>, Last = <span class="String">&quot;Skeet&quot;</span> },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Tom&quot;</span>, Last = <span class="String">&quot;SKEET&quot;</span> }, <span class="InlineComment">// Note upper-cased name</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Juni&quot;</span>, Last = <span class="String">&quot;Cortez&quot;</span> },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Holly&quot;</span>, Last = <span class="String">&quot;Skeet&quot;</span> },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Abbey&quot;</span>, Last = <span class="String">&quot;Bartlet&quot;</span> },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Carmen&quot;</span>, Last = <span class="String">&quot;Cortez&quot;</span> },&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { First = <span class="String">&quot;Jed&quot;</span>, Last = <span class="String">&quot;Bartlet&quot;</span> }     <br />&#160;&#160;&#160; };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = people.ToLookup(p =&gt; p.Last, p =&gt; p.First, StringComparer.OrdinalIgnoreCase);     <br />    <br />&#160;&#160;&#160; lookup[<span class="String">&quot;Skeet&quot;</span>].AssertSequenceEqual(<span class="String">&quot;Jon&quot;</span>, <span class="String">&quot;Tom&quot;</span>, <span class="String">&quot;Holly&quot;</span>);     <br />&#160;&#160;&#160; lookup[<span class="String">&quot;Cortez&quot;</span>].AssertSequenceEqual(<span class="String">&quot;Juni&quot;</span>, <span class="String">&quot;Carmen&quot;</span>);     <br />&#160;&#160;&#160; <span class="InlineComment">// The key comparer is used for lookups too</span>     <br />&#160;&#160;&#160; lookup[<span class="String">&quot;BARTLET&quot;</span>].AssertSequenceEqual(<span class="String">&quot;Abbey&quot;</span>, <span class="String">&quot;Jed&quot;</span>);     <br />    <br />&#160;&#160;&#160; lookup.Select(x =&gt; x.Key).AssertSequenceEqual(<span class="String">&quot;Skeet&quot;</span>, <span class="String">&quot;Cortez&quot;</span>, <span class="String">&quot;Bartlet&quot;</span>);     <br />} </div>  <p>I&#39;m sure there are plenty of other tests I could have come up with. lf you want to see any ones in particular (either as an edit to this post if they already exist in source control, or as entirely new tests), please leave a comment.</p>  <p>EDIT: It turned out there were a few important tests missing... see the addendum.</p>  <h3>Let&#39;s implement it!</h3>  <p>There&#39;s quite a lot of code involved in implementing this - but it should be reusable later on, potentially with a few tweaks. Let&#39;s get the first three overloads out of the way to start with:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TSource&gt; ToLookup&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.ToLookup(keySelector, element =&gt; element, EqualityComparer&lt;TKey&gt;.Default);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TSource&gt; ToLookup&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.ToLookup(keySelector, element =&gt; element, comparer);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.ToLookup(keySelector, elementSelector, EqualityComparer&lt;TKey&gt;.Default);     <br />} </div>  <p>Now we can just worry about the final one. Before we implement that though, we&#39;re definitely going to need an implementation of IGrouping. Let&#39;s come up with a really simple one to start with:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="Modifier">sealed</span>&#160;<span class="ReferenceType">class</span> Grouping&lt;TKey, TElement&gt; : IGrouping&lt;TKey, TElement&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> TKey key;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IEnumerable&lt;TElement&gt; elements;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> Grouping(TKey key, IEnumerable&lt;TElement&gt; elements)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.key = key;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.elements = elements;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> TKey Key { get { <span class="Statement">return</span> key; } }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> IEnumerator&lt;TElement&gt; GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> elements.GetEnumerator();     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; IEnumerator IEnumerable.GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> GetEnumerator();     <br />&#160;&#160;&#160; }     <br />} </div>  <p>How do we feel about this? Well, groupings should be immutable. We have no guarantee that the &quot;values&quot; sequence won&#39;t be changed after creation - but it&#39;s an internal class, so we&#39;ve just got to be careful about how we use it. We also have to be careful that we don&#39;t use a mutable sequence type which allows a caller to get from the iterator (the IEnumerator&lt;TElement&gt; returned by GetEnumerator) back to the sequence and then mutate it. In our case we&#39;re actually going to use List&lt;T&gt; to provide the sequences, and while List&lt;T&gt;.Enumerator is a public type, it doesn&#39;t expose the underlying list. Of course a caller could use reflection to mess with things, but we&#39;re not going to try to protect against that.</p>  <p>Okay, so now we can pair a sequence with a key... but we still need to implement ILookup. This is where there are multiple options. We want our lookup to be immutable, but there are various degrees of immutability we could use:</p>  <ul>   <li>Mutable internally, immutable in public API </li>    <li>Mutable privately, immutable to the internal API </li>    <li>Totally immutable, even within the class itself </li> </ul>  <p>The first option is the simplest to implement, and it&#39;s what I&#39;ve gone for at the moment. I&#39;ve created a Lookup class which is allows a key/element pair to be added to it from within the Edulinq assembly. It uses a Dictionary&lt;TKey, List&lt;TElement&gt;&gt; to map the keys to sequences efficiently, and a List&lt;TKey&gt; to remember the order in which we first saw the keys. Here&#39;s the complete implementation:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="Modifier">sealed</span>&#160;<span class="ReferenceType">class</span> Lookup&lt;TKey, TElement&gt; : ILookup&lt;TKey, TElement&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> Dictionary&lt;TKey, List&lt;TElement&gt;&gt; map;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> List&lt;TKey&gt; keys;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> Lookup(IEqualityComparer&lt;TKey&gt; comparer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; map = <span class="Keyword">new</span> Dictionary&lt;TKey, List&lt;TElement&gt;&gt;(comparer);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; keys = <span class="Keyword">new</span> List&lt;TKey&gt;();     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span>&#160;<span class="ValueType">void</span> Add(TKey key, TElement element)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;TElement&gt; list;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!map.TryGetValue(key, <span class="MethodParameter">out</span> list))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; list = <span class="Keyword">new</span> List&lt;TElement&gt;();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; map[key] = list;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; keys.Add(key);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; list.Add(element);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">int</span> Count     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; get { <span class="Statement">return</span> map.Count; }     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> IEnumerable&lt;TElement&gt; <span class="Keyword">this</span>[TKey key]     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; get     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;TElement&gt; list;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!map.TryGetValue(key, <span class="MethodParameter">out</span> list))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> Enumerable.Empty&lt;TElement&gt;();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> list.Select(x =&gt; x);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">bool</span> Contains(TKey key)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> map.ContainsKey(key);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> IEnumerator&lt;IGrouping&lt;TKey, TElement&gt;&gt; GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> keys.Select(key =&gt; <span class="Keyword">new</span> Grouping&lt;TKey, TElement&gt;(key, map[key]))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .GetEnumerator();     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; IEnumerator IEnumerable.GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> GetEnumerator();     <br />&#160;&#160;&#160; }     <br />} </div>  <p>All of this is really quite straightforward. Note that we provide an equality comparer to the constructor, which is then passed onto the dictionary - that&#39;s the only thing that needs to know how to compare keys.</p>  <p>There are only two points of interest, really:</p>  <ul>   <li>In the indexer, we don&#39;t return the list itself - that would allow the caller to mutate it, after casting it to List&lt;TElement&gt;. Instead, we just call Select with an identity projection, as a simple way of inserting a sort of &quot;buffering&quot; layer between the list and the caller. There are other ways of doing this, of course - including implementing the indexer with an iterator block. </li>    <li>In GetEnumerator, we&#39;re retaining the key order by using our list of keys and performing a lookup on each key. </li> </ul>  <p>We&#39;re currently creating the new Grouping objects lazily - which will lead to fewer of them being created if the caller doesn&#39;t actually iterate over the lookup, but more of them if the caller iterates over it several times. Again, there are alternatives here - but without any good information about where to make the trade-off, I&#39;ve just gone for the simplest code which works for the moment.</p>  <p>One last thing to note about Lookup - I&#39;ve left it internal. In .NET, it&#39;s actually public - but the only way of getting at an instance of it is to call ToLookup and then cast the result. I see no particular reason to make it public, so I haven&#39;t.</p>  <p>Now we&#39;re finally ready to implement the last ToLookup overload - and it becomes pretty much trivial:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> ILookup&lt;TKey, TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (elementSelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;elementSelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; Lookup&lt;TKey, TElement&gt; lookup = <span class="Keyword">new</span> Lookup&lt;TKey, TElement&gt;(comparer ?? EqualityComparer&lt;TKey&gt;.Default);     <br />    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TKey key = keySelector(item);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TElement element = elementSelector(item);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; lookup.Add(key, element);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> lookup;     <br />} </div>  <p>When you look past the argument validation, we&#39;re just creating a Lookup, populating it, and then returning it. Simple.</p>  <h3>Thread safety</h3>  <p>Something I haven&#39;t addressed anywhere so far is thead safety. In particular, although all of this is nicely immutable when viewed from a single thread, I have a nasty feeling that <em>theoretically</em>, if the return value of our implementation of ToLookup was exposed to another thread, it could potentially observe the internal mutations we&#39;re making here, as we&#39;re not doing anything special in terms of the memory model here.</p>  <p>I&#39;m basically scared by lock-free programming these days, unless I&#39;m using building blocks provided by someone else. While investigating the exact guarantees offered here would be interesting, I don&#39;t think it would really help with our understanding of LINQ as a whole. I&#39;m therefore declaring thread safety to be out of scope for Edulinq in general :)</p>  <h3>Conclusion</h3>  <p>So that&#39;s ToLookup. Two new interfaces, two new classes, all for one new operator... so far. We can reuse almost all of this in Join though, which will make it very simple to implement. Stay tuned...</p>  <h3>Addendum</h3>  <p>It turns out that I missed something quite important: ToLookup has to handle null keys, as do various other LINQ operators (GroupBy etc). We&#39;re currently using a Dictionary&lt;TKey, TValue&gt; to organize the groups... and that doesn&#39;t support null keys. Oops.</p>  <p>So, first steps: write some tests proving that it fails as we expect it to. Fetch by a null key of a lookup. Include a null key in the source of a lookup. Use GroupBy, GroupJoin and Join with a null key. Watch it go bang. That&#39;s the easy part...</p>  <p>Now, we <em>can</em> do all the special-casing in Lookup itself - but it gets ugly. Our Lookup code was pretty simple before; it seems a shame to spoil it with checks everywhere. What we really need is a dictionary which <em>does</em> support null keys. Step forward NullKeyFriendlyDictionary, a new internal class in Edulinq. Now you might <em>expect</em> this to implement IDictionary&lt;TKey, TValue&gt;, but it turns out that&#39;s a pain in the neck. We hardly use any of the members of Dictionary - TryGetValue, the indexer, ContainsKey, and the Count property. That&#39;s it! So those are the only members I&#39;ve implemented.</p>  <p>The class contains a Dictionary&lt;TKey, TValue&gt; to delegate <em>most</em> requests to, and it just handles null keys itself. Here&#39;s a quick sample:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="Modifier">sealed</span>&#160;<span class="ReferenceType">class</span> NullKeyFriendlyDictionary&lt;TKey, TValue&gt;    <br />{    <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> Dictionary&lt;TKey, TValue&gt; map;    <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="ValueType">bool</span> haveNullKey = <span class="Keyword">false</span>;    <br />&#160;&#160;&#160; <span class="Modifier">private</span> TValue valueForNullKey;    <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> NullKeyFriendlyDictionary(IEqualityComparer&lt;TKey&gt; comparer)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; map = <span class="Keyword">new</span> Dictionary&lt;TKey, TValue&gt;(comparer);    <br />&#160;&#160;&#160; }    <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span>&#160;<span class="ValueType">bool</span> TryGetValue(TKey key, <span class="MethodParameter">out</span> TValue value)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (key == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// This will be default(TValue) if haveNullKey is false,</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// which is what we want.</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; value = valueForNullKey;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> haveNullKey;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> map.TryGetValue(key, <span class="MethodParameter">out</span> value);    <br />&#160;&#160;&#160; }    <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// etc</span>    <br />} </div>  <p>There&#39;s <em>one</em> potential flaw here, that I can think of: if you provide an IEqualityComparer&lt;TKey&gt; which treats some non-null key as equal to a null key, we won&#39;t spot that. If your source then contains both those keys, we&#39;ll end up splitting them into two groups instead of keeping them together. I&#39;m not too worried about that - and I suspect there are all kinds of ways that could cause problems elsewhere anyway.</p>  <p>With this in place, and Lookup adjusted to use NullKeyFriendlyDictionary instead of just Dictionary, all the tests pass. Hooray!</p>  <p>At the same time as implementing this, I&#39;ve tidied up Grouping itself - it now implements IList&lt;T&gt; itself, in a way which is immutable to the outside world. The Lookup now contains groups directly, and can return them very easily. The code is generally tidier, and anything using a group can take advantage of the optimizations applied to IList&lt;T&gt; - particularly the Count() operator, which is often applied to groups.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
