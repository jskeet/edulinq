<html>
<head>
<title>Reimplementing LINQ to Objects: Part 29 - Min/Max</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 29 - Min/Max</h1>
<p>The second and third AOOOD operators today... if I&#39;m brave enough to tackle Average tomorrow, I&#39;ll have done them all. More surprises here today, this time in terms of documentation...</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.min.aspx">Min</a> and <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.max.aspx">Max</a> are both extension methods with 22 overloads <em>each</em>. Min looks like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Min(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Min&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>&gt; selector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Min(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Min&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>?&gt; selector)     <br />    <br /><span class="InlineComment">// Repeat the above four overloads for long, float, double and decimal,</span>     <br /><span class="InlineComment">// then add two more generic ones:</span>     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Min&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TResult Min&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TResult&gt; selector     <br />) </div>  <p>(Max is <em>exactly</em> the same as Min; just replace the name.)</p>  <p>The more obvious aspects of the behaviour are as follows:</p>  <ul>   <li>source and selector mustn&#39;t be null </li>    <li>All overloads use immediate execution </li>    <li>The minimum or maximum value within the sequence is returned </li>    <li>If a selector is present, it is applied to each value within source, and the maximum of the <em>projected</em> values is returned. (Note how the return type of these methods is TResult, not TSource.) </li> </ul>  <p>Some less obvious aspects - in all cases referring to the result type (as the source type is somewhat incidental when a selector is present; it doesn&#39;t affect the behaviour):</p>  <ul>   <li>The type&#39;s IComparable&lt;T&gt; implementation is used when available, otherwise IComparable is used. An ArgumentException is thrown if values can&#39;t be compared. Fortunately, this is exactly the behaviour of <a href="http://msdn.microsoft.com/en-us/library/azhsac5f.aspx">Comparer&lt;T&gt;.Default</a>. </li>    <li>For any nullable type (whether it&#39;s a reference type or a nullable value type), nulls within the sequence are ignored, and an empty sequence (or one which contains only null values) will cause a null value to be returned. If there are any non-null values in the sequence, the return value will be non-null. (Note that this is different from Sum, which will return the <em>non-null</em> zero value for empty sequences over nullable types.)</li>    <li>For any non-nullable value type, an empty sequence will cause InvalidOperationException to be thrown. </li> </ul>  <p>The first point is particularly interesting when you consider the double and float types, and their &quot;NaN&quot; (not-a-number) values. For example, Math.Max regards NaN as greater than positive infinity, but Enumerable.Max regards positive infinity as being the greater of the two. Math.Min and Enumerable.Min agree, however, that NaN is less than negative infinity. (It would actually make sense to me for NaN to be treated as the numeric equivalent of null here, but that would be strange in other ways...) Basically, NaN behaves oddly in all kinds of ways. I believe that <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4610935">IEEE-754-2008</a> actually specifies behaviour with NaNs which encourages the results we&#39;re getting here, but I haven&#39;t verified that yet. (I can&#39;t find a free version of the standard online, which is troubling in itself. Ah well.)</p>  <p>The behaviour of the nullable and non-nullable types is well documented for the type-specific overloads using int, Nullable&lt;int&gt; etc. However, the generic overloads (the ones using TSource) are poorly documented:</p>  <ul>   <li>InvalidOperationException isn&#39;t in the list of possibly-thrown arguments for any of the overloads </li>    <li>The methods using selectors from TSource to TResult don&#39;t mention the possibility of nullity at all </li>    <li>The methods without selectors describe the behaviour of null values <em>for reference types</em>, but don&#39;t mention the possibility of empty sequences for non-nullable value types, or consider nullable value types at all. </li> </ul>  <p>(I should point out that ArgumentException isn&#39;t actually mentioned either for the case where values are incomparable, but that feels like a slightly less important offence for some reason. Possibly just because it didn&#39;t trip me up.)</p>  <p>If I remember, I&#39;ll open a Connect issue against this hole in the documentation when I find time. Unlike the optimizations and set ordering (where it&#39;s reasonably forgivable to deliberately omit implementation details from the contract) you simply can&#39;t predict the behaviour in a useful way from the documentation here. And yes, I&#39;m going on about this because it bit me. I had to resort to writing tests and running them against LINQ to Objects to see if they were correct or not. (They were incorrect in various places.)</p>  <p>If you look at the behaviour of the non-generic methods, the generic ones are entirely consistent of course.</p>  <p>There are a couple of things which you might consider &quot;missing&quot; in terms of Max and Min:</p>  <ul>   <li>The ability to find out the minimum/maximum value of a sequence <em>by</em> a projection. For example, consider a sequence of people. We may wish to find the youngest person in the sequence, in which case we&#39;d like to be able to write something like:       <div class="code"><span class="Linq">var</span> oldest = people.MaxBy(person =&gt; person.Age); </div> We can find the maximum age itself easily enough - but then we&#39;d need a second pass to find the first person <i>with</i> that age. I&#39;ve addressed this in <a href="http://morelinq.googlecode.com">MoreLINQ</a> with the MaxBy and MinBy operators. The System.Interactive assembly in <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896">Reactive Extensions</a> has the same methods too. </li>    <li>The ability to specify a custom IComparer&lt;T&gt; implementation, as we can in most of the operators using IEqualityComparer&lt;T&gt;. For example, we can&#39;t find the &quot;maximum&quot; string in a sequence, using a case-insensitive ordinal comparison. </li> </ul>  <p>Still, at least that means there&#39;s less to test...</p>  <h3>What are we going to test?</h3>  <p>I decided I really couldn&#39;t find the energy to replicate all the tests for every type involved here. Instead, I have a bunch of tests for int and Nullable&lt;int&gt;, a few tests exploring the oddness of doubles, and a bunch of tests around the generic methods. In particular, I know that I&#39;ve implemented decimal, float etc by calling the same methods that the int overloads use.</p>  <p>The tests cover:</p>  <ul>   <li>Argument validation </li>    <li>Empty sequences </li>    <li>Sequences of null values where applicable </li>    <li>Projections of the above </li>    <li>Generic tests for nullable and non-nullable value types, and reference types (with empty sequences etc) </li>    <li>Incomparable values </li> </ul>  <h3>Let&#39;s implement them!</h3>  <p>Okay, let&#39;s start off with the simplest detail: the order of implementation:</p>  <ul>   <li>Max(int) </li>    <li>Max(generic) </li>    <li>Cut and paste Max implementations for other numeric types (replace the type name, basically) </li>    <li>Cut and paste the entirety of Max to Min:      <ul>       <li>Replace &quot;Max&quot; with &quot;Min&quot; everywhere </li>        <li>Replace &quot; &lt; &quot; with &quot; &gt; &quot; everywhere (only 4 occurrences; basically the results of calling Compare or ComparerTo and comparing with 0) </li>     </ul>   </li> </ul>  <p>Just as with Sum, I could have used templating - but I don&#39;t think it would actually have saved me significant time.</p>  <p>This time, I thought I&#39;d use Select internally for the overloads with selectors (unlike my approach for Sum which used identity projections). There&#39;s no particular reason for this - I just thought it would be interesting to try both approaches. Overall, I think I prefer this one, but I haven&#39;t done any benchmarking to find out the relative performance penalties.</p>  <p>Each set of numeric overloads calls into a single pair of generic &quot;implementation&quot; methods. These aren&#39;t the public general-purpose ones: they require that the types in use implement IComparable&lt;T&gt;, and I&#39;ve added a &quot;struct&quot; constraint just for kicks. This is just one approach. Other options:</p>  <ul>   <li>I could have implemented the code separately for each numeric type. That may well be faster than calling IComparable&lt;T&gt;.Compare (at least for most types) as the IL would have contained the appropriate operator directly. However, it would have meant more code and explicitly dealing with the headache of NaNs for double/float. If I ever write benchmarks, I&#39;ll investigate the difference that this can make. </li>    <li>I could have used the public generic overloads, which eventually call into Comparer&lt;T&gt;.Default. Again, the penalty for this (if any) is unknown to me at this point. Can the JIT inline deeply enough to make this as fast as a &quot;native&quot; implementation? I wouldn&#39;t like to guess without tests. </li> </ul>  <p>I&#39;ve separated out the nullable implementations from the non-nullable ones, as the behaviour differs significantly between the two.</p>  <p>Here&#39;s the public code for int:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Max(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> PrimitiveMax(source);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Max&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Select will validate the arguments</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> PrimitiveMax(source.Select(selector));     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Max(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> NullablePrimitiveMax(source);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Max&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>?&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Select will validate the arguments</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> NullablePrimitiveMax(source.Select(selector));     <br />} </div>  <p>All the methods consider argument validation to be somebody else&#39;s problem - either Select or the generic method we&#39;re calling to find the maximum value. Part of me thinks this is lazy; part of me likes it in terms of not repeating code. All of me would prefer the ability to specify non-nullable parameters declaratively...</p>  <p>Here are the &quot;primitive&quot; methods called into above:</p>  <div class="code"><span class="InlineComment">// These are uses by all the overloads which use a known numeric type.</span>     <br /><span class="InlineComment">// The term &quot;primitive&quot; isn&#39;t truly accurate here as decimal is not a primitive</span>     <br /><span class="InlineComment">// type, but it captures the aim reasonably well.</span>     <br /><span class="InlineComment">// The constraint of being a value type isn&#39;t really required, because we don&#39;t rely on</span>     <br /><span class="InlineComment">// it within the method and only code which already knows it&#39;s a comparable value type</span>     <br /><span class="InlineComment">// will call these methods anyway.</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> T PrimitiveMax&lt;T&gt;(IEnumerable&lt;T&gt; source) <span class="Linq">where</span> T : <span class="ValueType">struct</span>, IComparable&lt;T&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;T&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; T max = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; T item = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (max.CompareTo(item) &lt; 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; max = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> max;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> T? NullablePrimitiveMax&lt;T&gt;(IEnumerable&lt;T?&gt; source) <span class="Linq">where</span> T : <span class="ValueType">struct</span>, IComparable&lt;T&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; T? max = <span class="Keyword">null</span>;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (T? item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (item != <span class="Keyword">null</span> &amp;&amp;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (max == <span class="Keyword">null</span> || max.Value.CompareTo(item.Value) &lt; 0))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; max = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> max;     <br />} </div>  <p>The first method is interesting in terms of its approach to throwing an exception if the first element isn&#39;t present, and using that as an initial candidate otherwise.</p>  <p>The second method needs to consider nullity twice on each iteration:</p>  <ul>   <li>Is the item from the sequence null? If so, we can ignore it. </li>    <li>Is our &quot;current maximum&quot; null? If so, we can replace it with the item from the sequence without performing a comparison. </li> </ul>  <p>Now there&#39;s one case which is ambiguous here: when <em>both</em> values are null. At that point we can choose to replace our &quot;current maximum&quot; with the item, or not... it doesn&#39;t matter as the values are the same anyway. It <em>is</em> important that we don&#39;t try to perform a comparison unless both values are non-null though... the short-circuiting &amp;&amp; and || operators keep us safe here.</p>  <p>Having implemented the code above, all the <em>interesting</em> work lies in the generic forms. Here we don&#39;t have different public methods to determine which kind of behaviour we&#39;ll use: but I wrote two <em>private</em> methods instead, and just delegated to the right one from the public one. This seemed cleaner than putting the code all in one method:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Max&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="InlineComment">// This condition will be true for reference types and nullable value types, and false for</span>    <br />&#160;&#160;&#160; <span class="InlineComment">// non-nullable value types.</span>    <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Modifier">default</span>(TSource) == <span class="Keyword">null</span> ? NullableGenericMax(source) : NonNullableGenericMax(source);    <br />}    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TResult Max&lt;TSource, TResult&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; Func&lt;TSource, TResult&gt; selector)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">return</span> Max(source.Select(selector));    <br />}    <br />    <br /><span class="XmlComment">/// &lt;summary&gt;</span>    <br /><span class="XmlComment">/// Implements the generic behaviour for non-nullable value types.</span>    <br /><span class="XmlComment">/// &lt;/summary&gt;</span>    <br /><span class="XmlComment">/// &lt;remarks&gt;</span>    <br /><span class="XmlComment">/// Empty sequences will cause an InvalidOperationException to be thrown.</span>    <br /><span class="XmlComment">/// Note that there&#39;s no *compile-time* validation in the caller that the type</span>    <br /><span class="XmlComment">/// is a non-nullable value type, hence the lack of a constraint on T.</span>    <br /><span class="XmlComment">/// &lt;/remarks&gt;</span>    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> T NonNullableGenericMax&lt;T&gt;(IEnumerable&lt;T&gt; source)    <br />{    <br />&#160;&#160;&#160; Comparer&lt;T&gt; comparer = Comparer&lt;T&gt;.Default;    <br />    <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;T&gt; iterator = source.GetEnumerator())    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; T max = iterator.Current;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; T item = iterator.Current;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (comparer.Compare(max, item) &lt; 0)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; max = item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> max;    <br />&#160;&#160;&#160; }    <br />}    <br />    <br /><span class="XmlComment">/// &lt;summary&gt;</span>    <br /><span class="XmlComment">/// Implements the generic behaviour for nullable types - both reference types and nullable</span>    <br /><span class="XmlComment">/// value types.</span>    <br /><span class="XmlComment">/// &lt;/summary&gt;</span>    <br /><span class="XmlComment">/// &lt;remarks&gt;</span>    <br /><span class="XmlComment">/// Empty sequences and sequences comprising only of null values will cause the null value</span>    <br /><span class="XmlComment">/// to be returned. Any sequence containing non-null values will return a non-null value.</span>    <br /><span class="XmlComment">/// &lt;/remarks&gt;</span>    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> T NullableGenericMax&lt;T&gt;(IEnumerable&lt;T&gt; source)    <br />{    <br />&#160;&#160;&#160; Comparer&lt;T&gt; comparer = Comparer&lt;T&gt;.Default;    <br />    <br />&#160;&#160;&#160; T max = <span class="Modifier">default</span>(T);    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (T item <span class="Statement">in</span> source)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (item != <span class="Keyword">null</span> &amp;&amp;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (max == <span class="Keyword">null</span> || comparer.Compare(max, item) &lt; 0))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; max = item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> max;    <br />} </div>  <p>As you can tell, there&#39;s a significant similarity between the &quot;PrimitiveMax&quot; and &quot;NonNullableGenericMax&quot; methods, and likewise between &quot;NullablePrimitiveMax&quot; and &quot;NullableGenericMax&quot;. This should come as no surprise. Fundamentally the difference is just between using an IComparable&lt;T&gt; implementation, and using Comparer&lt;T&gt;.Default. (The argument validation occurs in a different place too, as we&#39;ll be going through a public entry point for the non-primitive code.)</p>  <p>Once I&#39;d discovered the correct behaviour, this was reasonably simple. Of course, the above code wasn&#39;t my <em>first </em>implementation, where I&#39;d completely forgotten about null values, and hadn&#39;t thought about how the nullability of the source type might affect the behaviour of empty sequences...</p>  <h3>Conclusion</h3>  <p>If you&#39;re ever in a company which rewards you for checking in lots of lines of code, offer to implement Sum/Min/Max. This weekend I&#39;ve checked in about 2,500 lines of code in (split between production and test) and none of it&#39;s been terribly hard. Of course, if you&#39;re ever in such a company you should <em>also </em>consider looking for another job. (Have I mentioned that Google&#39;s hiring? <a href="mailto:skeet@pobox.com">Email me</a> if you&#39;re interested. I&#39;m serious.)</p>  <p>As you can tell, I was slightly irritated by the lack of clarity around the documentation in some places - but I find it interesting that even a simple-sounding function like &quot;find the maximum value from a sequence&quot; should <em>need</em> the kind of documentation that&#39;s missing here. I&#39;m not saying it&#39;s a failure of the design - more just musing how a complete specification is almost always going to be longer than you might think at first glance. And if you think I was diligent here, think again: I didn&#39;t bother specifying <em>which</em> maximum or minimum value would be returned if there were two. For example, if a sequence consists of references to two equal but distinct strings, which reference should be returned? I have neither stated what my implementation (or the LINQ to Objects implementation) will do, nor tested for it.</p>  <p>Next up is Average - a single method with a mere 20 overloads. There are various corner cases to consider... but that&#39;s a post for another day.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
