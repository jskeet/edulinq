<html>
<head>
<title>Reimplementing LINQ to Objects: Part 23 - Take/Skip/TakeWhile/SkipWhile</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 23 - Take/Skip/TakeWhile/SkipWhile</h1>
<p>I genuinely expected these operators to be simple. At the time of this writing, I&#39;m onto my third implementation of SkipWhile, struggling to find code which obviously expresses what&#39;s going on. I find it interesting how the simplest sounding operators sometimes end up being trickier to implement than one might think.</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb503062.aspx">Take</a>, <a href="http://msdn.microsoft.com/en-us/library/bb348003.aspx">TakeWhile</a>, <a href="http://msdn.microsoft.com/en-us/library/bb358985.aspx">Skip</a> and <a href="http://msdn.microsoft.com/en-us/library/bb348298.aspx">SkipWhile</a> form a natural group of operators. Together they are known as the <em>partitioning</em> operators. Here are the signatures:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Take&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate) </div>  <p>The behaviour is <em>reasonably</em> self-explanatory:</p>  <ul>   <li>source.Take(n) returns a sequence of the first n elements of source </li>    <li>source.Skip(n) returns a sequence containing <em>all but</em> the first n elements of source </li>    <li>source.TakeWhile(predicate) returns a sequence of the first elements of source which match the given predicate; it stops as soon as the predicate fails to match </li>    <li>source.SkipWhile(predicate) returns a sequence of <em>all but</em> the the first elements of source which match the given predicate; it starts yielding results as soon as the predicate fails to match </li> </ul>  <p>The only reason there are two overloads for TakeWhile and SkipWhile is so that you can provide a predicate which uses the index within the sequence, just like the overloads for Select and Where.</p>  <p>Each operator effectively partitions the input sequence into two parts, and yields either the first or second part. So for any &quot;normal&quot; collection (which returns the same results each time you iterate over it) the following are true:</p>  <ul>   <li>source.Take(n).Concat(source.Skip(n)) is equivalent to source </li>    <li>source.TakeWhile(predicate).Concat(source.SkipWhile(predicate)) is equivalent to source (as noted in the comments, this is also assuming the predicate acts solely the same way each time it&#39;s given the same data, without any side-effects) </li> </ul>  <p>A few notes on general behaviour:</p>  <ul>   <li>The arguments are validated eagerly: source and predicate can&#39;t be null </li>    <li>count <em>can</em> be negative (in which case it&#39;s equivalent to 0) and can be larger than the collection too. Basically any value is valid. </li>    <li>Execution is deferred. </li>    <li>The source sequence is streamed - there&#39;s no need to buffer anything. </li> </ul>  <h3>What are we going to test?</h3>  <p>One nice thing about the properties I described earlier is that it&#39;s very easy to convert tests for Take/TakeWhile into tests for Skip/SkipWhile: you just change the expected sequence in Skip to be everything in the source sequence which <em>wasn&#39;t</em> in the test for Take. For Take/Skip I&#39;ve just used Enumerable.Range(0, 5) (i.e. 0, 1, 2, 3, 4) as the source sequence; for TakeWhile/SkipWhile I&#39;ve used { &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot; } - so each element is the word corresponding to the index. That makes it reasonably easy to write tests with a predicate involving the index.</p>  <p>I&#39;ve tested:</p>  <ul>   <li>Argument validation </li>    <li>Deferred execution </li>    <li>For Skip/Take:      <ul>       <li>A negative count </li>        <li>A count of 0 </li>        <li>A count to split the sequence into non-empty parts </li>        <li>A count exactly equal to the source length (5) </li>        <li>A count larger than the source length </li>     </ul>   </li>    <li>For SkipWhile/TakeWhile (both overloads in each case):      <ul>       <li>A predicate which fails on the first element </li>        <li>A predicate which matches some elements but not others </li>        <li>A predicate which matches all elements </li>     </ul>   </li> </ul>  <p>The tests aren&#39;t generally interesting, but as it can be slightly tricky to get your head round TakeWhile and SkipWhile to start with, here&#39;s an example of each:</p>  <div class="code"><span class="InlineComment">// In TakeWhileTest</span>     <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> PredicateMatchingSomeElements()     <br />{     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] source = { <span class="String">&quot;zero&quot;</span>, <span class="String">&quot;one&quot;</span>, <span class="String">&quot;two&quot;</span>, <span class="String">&quot;three&quot;</span>, <span class="String">&quot;four&quot;</span>, <span class="String">&quot;five&quot;</span> };     <br />&#160;&#160;&#160; source.TakeWhile(x =&gt; x.Length &lt; 5).AssertSequenceEqual(<span class="String">&quot;zero&quot;</span>, <span class="String">&quot;one&quot;</span>, <span class="String">&quot;two&quot;</span>);     <br />}     <br />    <br /><span class="InlineComment">// In SkipWhileTest</span>     <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> PredicateMatchingSomeElements()     <br />{     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] source = { <span class="String">&quot;zero&quot;</span>, <span class="String">&quot;one&quot;</span>, <span class="String">&quot;two&quot;</span>, <span class="String">&quot;three&quot;</span>, <span class="String">&quot;four&quot;</span>, <span class="String">&quot;five&quot;</span> };     <br />&#160;&#160;&#160; source.SkipWhile(x =&gt; x.Length &lt; 5).AssertSequenceEqual(<span class="String">&quot;three&quot;</span>, <span class="String">&quot;four&quot;</span>, <span class="String">&quot;five&quot;</span>);     <br />} </div>  <p>There&#39;s been some discussion on Twitter about the best kind of test here, with suggestions of varying the data instead of the predicate, and using sequences of Boolean values. Personally I prefer the tests the way they are - I find this sequence of strings easy to work with, and the fact that it <em>is</em> a sequence of strings means you can&#39;t get the index/value parameter order wrong when providing a predicate which uses the indexes, unlike if you use an integer sequence. A Boolean sequence isn&#39;t clear enough for me - the result isn&#39;t obviously the first or second part of a sequence, whereas with these words, it&#39;s obvious what&#39;s going on... to me, at least. It&#39;s all a matter of personal preference though, and it&#39;s good to think about alternatives.</p>  <h3>Let&#39;s implement them!</h3>  <p>Let me present this in chronological order. I started off by implementing Take and Skip, as they sounded the simplest. Indeed, they&#39;re not too bad - here are the iterator block parts, after argument validation in the public method, of course:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; TakeImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; count &amp;&amp; iterator.MoveNext(); i++)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; SkipImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; count; i++)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>These really aren&#39;t too bad, although it&#39;s interesting to note that Skip is more complicated than Take: Skip has to deal with both sections of the sequence (the &quot;ignore&quot; part and the &quot;yield&quot; part) whereas Take can return as soon as it&#39;s finished with the &quot;yield&quot; part. We&#39;ll see the same pattern in TakeWhile/SkipWhile.</p>  <p>Speaking of which, let&#39;s look at them. There&#39;s a decision to make in terms of whether to implement the overload whose predicate <em>doesn&#39;t</em> use the index in terms of the one which does. It would certainly be simple, but I don&#39;t like the double level of indirection with one delegate calling another. It may well be irrational, given that I&#39;ve been introducing identity delegates elsewhere - but it just didn&#39;t feel right. I&#39;ve added it into the source code using conditional compilation just for completeness, but it&#39;s not the default implementation.</p>  <p>Now, the &quot;Impl&quot; bits of TakeWhile really weren&#39;t too bad:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; TakeWhileImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; TakeWhileImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index = 0;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!predicate(item, index))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; index++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Again, we don&#39;t need to worry about the second part of the sequence - the part we&#39;re ignoring. We can just let the method complete, and the result iterator terminate. In particular, we don&#39;t care about the value that caused the predicate to return false. Now let&#39;s look at SkipWhile (again, just the interesting bits):</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; SkipWhileImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource item = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Stop skipping now, and yield this item</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">break</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; SkipWhileImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> index = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource item = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!predicate(item, index))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Stop skipping now, and yield this item</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">break</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; index++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The above code is my third attempt. You can look at the first two in the <a href="http://code.google.com/p/edulinq/source/list?path=/src/Edulinq/SkipWhile.cs">history of SkipWhile.cs</a> - you may find one of those preferable. Other suggestions have been made, including ones using do/while... I must admit, the do/while option ends up being quite attractive, but again I have a general aversion to it as a construct. Part of the trickiness is that having found an element which makes the predicate return false, we have to yield that element before we move on to yielding the rest. It&#39;s easy enough to do, but the extra yield return statement feels ugly.</p>  <p>One point to note is that if the &quot;skipping&quot; part finishes due to a call to MoveNext returning false (rather than the predicate failing) then we&#39;ll call MoveNext again (at the start of the &quot;yielding&quot; loop). That&#39;s explicitly called out as being okay in the <a href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerator.movenext.aspx">IEnumerator.MoveNext() documentation</a>, so I&#39;m happy enough to use it.</p>  <p>I&#39;m certainly not happy about those implementations, but I&#39;m confident they at least work. Now, let&#39;s revisit Skip and Take. Is there any way we can simplify them? Absolutely - all we need to do is use TakeWhile or SkipWhile with a predicate which uses the index and compares it to the count we&#39;ve been given:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Take&lt;TSource&gt;(&#160; <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,&#160; <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)&#160; <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Buggy! See addendum... </span>    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.TakeWhile((x, index) =&gt; index &lt; count);&#160; <br />}&#160; <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt;(&#160; <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,&#160; <br />&#160;&#160;&#160; <span class="ValueType">int</span> count)&#160; <br />{&#160; <br />&#160;&#160;&#160; <span class="Statement">return</span> source.SkipWhile((x, index) =&gt; index &lt; count);&#160; <br />} </div>  <p>TakeWhile and SkipWhile even do the appropriate argument validation for us. As you can see, I&#39;ve become less averse to implementing one operator using another over time... both implementations are still in the source, using conditional compilation, but currently this short form is the one which is &quot;active&quot;. I could be persuaded to change my mind :)</p>  <h3>An optimized Skip?</h3>  <p>Although most of these operations can&#39;t be sensibly optimized, it <em>would</em> make sense to optimize Skip when the source implements IList&lt;T&gt;. We can skip the skipping, so to speak, and go straight to the appropriate index. This wouldn&#39;t spot the case where the source was modified between iterations, which <em>may</em> be one reason it&#39;s not implemented in the framework as far as I&#39;m aware. The optimization would look something like this:</p>  <div class="code"><span class="Linq">var</span> list = source <span class="Keyword">as</span> IList&lt;TSource&gt;;     <br /><span class="Statement">if</span> (list != <span class="Keyword">null</span>)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Make sure we don&#39;t use a negative index</span>     <br />&#160;&#160;&#160; count = Math.Max(count, 0);     <br />&#160;&#160;&#160; <span class="InlineComment">// Note that &quot;count&quot; is the count of items to skip</span>     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> index = count; index &lt; list.Count; index++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> list[index];     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />} </div>  <p>Should Edulinq do this? Answers on a postcard...</p>  <p>EDIT: There&#39;s another optimization we can potentially make, even earlier. If we&#39;re given a count which is zero or negative, Skip is effectively pointless - so we can just return the original reference. This would come just after the argument validation, not in the iterator block:</p>  <div class="code"><span class="Statement">if</span> (count &lt;= 0)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source;     <br />} </div>  <p>Returning the original reference has some implications in terms of not isolating the return value from the original sequence, but it&#39;s worth considering. We could potentially do the same for Take, in the case where we know it&#39;s a list and the requested count is greater than or equal to the size of the list.</p>  <h3>Using Skip and Take together</h3>  <p>It&#39;s worth mentioning the most common use of Skip and Take, as well as an easy-to-make mistake. Skip and Take are ideal for paging. For example:</p>  <div class="code"><span class="Linq">var</span> pageItems = allItems.Skip(pageNumber * itemsPerPage)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Take(itemsPerPage); </div>  <p>This simply skips as many items as it needs to, and only &quot;takes&quot; one page-worth of data afterwards. Very simple... but also easy to get wrong.</p>  <p>In many cases with LINQ, you can reorder operations with no harm - or with a compile-time error if you get them the wrong way round. Let&#39;s consider what happens if we get it wrong this time though:</p>  <div class="code"><span class="InlineComment">// Bug! Bug! Bug!</span>     <br /><span class="Linq">var</span> pageItems = allItems.Take(itemsPerPage)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Skip(pageNumber * itemsPerPage);</div>  <p>This will work for the first page, but after that you&#39;ll <em>always</em> end up displaying an empty page: it will take the first page-worth of data, and then skip it all, leaving nothing to return.</p>  <h3>Conclusion</h3>  <p>That was more work than I expected it to be. Still, we&#39;ve actually not got very many LINQ operators still to cover. By my reckoning, we still have the following operators to implement:</p>  <ul>   <li>Sum, Average, Min, Max - I&#39;m not looking forward to these, as they all have lots of overloads, and are likely to be tedious to test and implement. </li>    <li>Cast and OfType </li>    <li>ToArray and ToDictionary </li>    <li>ElementAt and ElementAtOrDefault - I should possibly have covered these along with First/Single/Last etc </li>    <li>SequenceEqual </li>    <li>Zip (from .NET 4) </li>    <li>Contains </li>    <li>OrderBy/OrderByDescending/ThenBy/ThenByDescending (probably the most <em>interesting</em> remaining operators) </li>    <li>Reverse </li> </ul>  <p>That&#39;s not too bad a list. I&#39;ll probably try to knock off ToArray tonight - it should be pretty simple.</p>  <h3>Addendum</h3>  <p>It turns out that my &quot;simplification&quot; for Take introduced a bug. If we only need to take two items, we should know that after we&#39;ve taken the second one... we don&#39;t really need to ask the iterator to move to the third item, just to decide that we&#39;ve finished. Doing so could have side effects - such as causing an exception to be thrown. That&#39;s exactly what we do when we use TakeWhile - we don&#39;t care what the first value after the stopping point is, but we <em>do</em> try to fetch it. Oops.</p>  <p>Fortunately the Mono tests picked this up for me, so I&#39;ve added my own test for it, and gone back to the original implementation of Take which just used a counter. Both my own tests and Mono&#39;s now pass :)</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
