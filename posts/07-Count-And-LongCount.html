<html>
<head>
<title>Reimplementing LINQ to Objects: Part 7 - Count and LongCount</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 7 - Count and LongCount</h1>
<p>Today&#39;s post covers two operators in one, because they&#39;re so incredibly similar... to the point cut and paste of implementation, merely changing the name, return type, and a couple of variables.</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.count.aspx" target="_blank">Count</a> and <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.longcount.aspx" target="_blank">LongCount</a> each have two overloads: one with a predicate, and one without. Here are all four signatures:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Count&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Count&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">long</span> LongCount&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">long</span> LongCount&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate) </div>  <p>As you can see, the LongCount signatures are identical to Count except in terms of their return types, which are long (Int64) instead of int (Int32).</p>  <p>The overloads without a predicate parameter simply return the number of items in the source collection; the ones with a predicate return the number of items for which that predicate returns true.</p>  <p>Interesting aspects of the behaviour:</p>  <ul>   <li>These are all extension methods on IEnumerable&lt;T&gt; - you might argue that for the versions without a predicate, it would have been better to extend the non-generic IEnumerable, as nothing actually requires the element type. </li>    <li>Where there&#39;s no predicate, Count is optimized for ICollection&lt;T&gt; and (in .NET 4) ICollection - both of which have Count properties which are expected to be faster than iterating over the entire collection. LongCount is <em>not</em> optimized in the same way in the .NET implementation - I&#39;ll discuss this in the implementation section. </li>    <li>No optimization is performed in the overloads with predicates, as basically there&#39;s no way of telling how many items will &quot;pass&quot; the predicate without testing them. </li>    <li>All methods use <em>immediate execution</em> - nothing is deferred. (If you think about it, there&#39;s nothing which <em>can</em> be deferred here, when we&#39;re just returning an int or a long.) </li>    <li>All arguments are validated simply by testing they&#39;re non-null </li>    <li>Both methods should throw OverflowException when given a collection with more items than they can return the count of... though this is a considerably larger number in the case of LongCount than Count, of course. </li> </ul>  <h3>What are we going to test?</h3>  <p>In some senses, there are only two &quot;success&quot; tests involved here: one without a predicate and one with. Those are easy enough to deal with, but we also want to exercise the optimized paths. That&#39;s actually trickier than it might sound, as we want to test four situations:</p>  <ul>   <li>A source which implements both ICollection&lt;T&gt; and ICollection (easy: use List&lt;T&gt;) </li>    <li>A source which implements ICollection&lt;T&gt; but not ICollection (reasonably easy, after a little work finding a suitable type: use HashSet&lt;T&gt;) </li>    <li>A source which implements ICollection but not ICollection&lt;T&gt; <em>but still implements IEnumerable&lt;T&gt;</em> (so that we can extend it) - tricky... </li>    <li>A source which doesn&#39;t implement ICollection or ICollection&lt;T&gt; (easy: use Enumerable.Range which we&#39;ve already implemented) </li> </ul>  <p>The third bullet is the nasty one. Obviously there are plenty of implementations of ICollection but not ICollection&lt;T&gt; (e.g. ArrayList) but because it doesn&#39;t implement IEnumerable&lt;T&gt;, we can&#39;t call the Count extension method on it. In the end I wrote my own SemiGenericCollection class.</p>  <p>Once we&#39;ve got sources for all those tests, we need to decide what we&#39;re actually testing about them. Arguably we <em>should</em> test that the result is optimized, for example by checking that we never really enumerate the collection. That would require writing custom collections with GetEnumerator() methods which threw exceptions, but still returned a count from the Count property. I haven&#39;t gone this far, but it&#39;s another step we certainly <em>could</em> take.</p>  <p>For the overloads which take predicates, we don&#39;t need to worry about the various collection interfaces as we&#39;re not optimizing anyway.</p>  <p>The failure cases for null arguments are very simple, but there&#39;s one other case to consider: overflow. For Count, I&#39;ve implemented a test case to verify the overflow behaviour. Unfortunately we can&#39;t run this test in the Edulinq implementation yet, as it requires Enumerable.Concat, but here it is for the record anyway:</p>  <div class="code">[Test]    <br />[Ignore(<span class="String">&quot;Takes an enormous amount of time!&quot;</span>)]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> Overflow()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> largeSequence = Enumerable.Range(0, <span class="ValueType">int</span>.MaxValue)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Concat(Enumerable.Range(0, 1));     <br />&#160;&#160;&#160; Assert.Throws&lt;OverflowException&gt;(() =&gt; largeSequence.Count());     <br />} </div>  <p>This guards against a bad implementation which overflows by simply wrapping the counter round to Int32.MinValue instead of throwing an exception.</p>  <p>As you can see, this test will be disabled even when it&#39;s uncommented after we implement Concat, as it requires counting up to 2 billion - not great for a quick set of unit tests. Even that isn&#39;t too bad, however, compared with the equivalent in LongCount which would have to count 2^63 items. Generating such a sequence isn&#39;t difficult, but iterating over it all would take a <em>very</em> long time. We also need an equivalent test for the overload with a predicate - something I neglected until writing up this blog post, and finding a bug in the implementation as I did so :)</p>  <p>For LongCount, I merely have an equivalent test to the above which checks that the same sequence <em>can</em> have its length expressed as a long value.</p>  <h3>Let&#39;s implement them!</h3>  <p>We&#39;ll look at the overload which <em>does</em> have a predicate first - as it&#39;s actually simpler:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Count&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// No way of optimizing this</span>     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> count = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; count++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> count;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Note that this time we&#39;re not using an iterator block (we&#39;re not returning a sequence), so we don&#39;t need to split the implementation into two different methods just to get eager argument validation.</p>  <p>After the argument validation, the main part of the method is reasonably simple, with one twist: we&#39;re performing the whole iteration within a &quot;checked&quot; context. This means that if the increment of count overflows, it will throw an OverflowException instead of wrapping round to a negative number. There are some other alternatives here:</p>  <ul>   <li>We could have made just the increment statement checked instead of the whole second part of the method </li>    <li>We could have explicitly tested for <code>count == int.MaxValue</code> before incrementing, and thrown an exception in that case </li>    <li>We could just build the whole assembly in a checked context </li> </ul>  <p>I think it&#39;s useful for this section of code to be explicitly checked - it makes it obvious that it really is a requirement for general correctness. You may well prefer to make only the increment operation checked - I personally believe that the current approach draws more attention to the checked-ness, but it&#39;s definitely a subjective matter. It&#39;s also possible that an explicit check could be faster, although I doubt it - I haven&#39;t benchmarked either approach.</p>  <p>Other than the predicate-specific parts, all the above code also appears in the optimized Count implementation - so I won&#39;t discuss those again. Here&#39;s the full method:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Count&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Optimization for ICollection&lt;T&gt;</span>     <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; genericCollection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (genericCollection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> genericCollection.Count;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Optimization for ICollection</span>     <br />&#160;&#160;&#160; ICollection nonGenericCollection = source <span class="Keyword">as</span> ICollection;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (nonGenericCollection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> nonGenericCollection.Count;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Do it the slow way - and make sure we overflow appropriately</span>     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> count = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = source.GetEnumerator())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; count++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> count;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The only &quot;new&quot; code here is the optimization. There are effectively two equivalent blocks, just testing for different collection interface types, and using whichever one it finds first (if any). I don&#39;t know whether the .NET implementation tests for ICollection or ICollection&lt;T&gt; first - I could test it by implementing both interfaces but returning different counts from each, of course, but that&#39;s probably overkill. It doesn&#39;t really matter for well-behaved collections other than the slight performance difference - we want to test the &quot;most likely&quot; interface first, which I believe is the generic one.</p>  <h3>To optimize or not to optimize?</h3>  <p>The LongCount implementations are exactly the same as those for Count, except using long instead of int.</p>  <p>Notably, I still use optimizations for ICollection and ICollection&lt;T&gt; - but I don&#39;t believe the .NET implementation does so. (It&#39;s easy enough to tell by creating a huge list of bytes and comparing the time taken for Count and LongCount.)</p>  <p>There&#39;s an argument for using <a href="http://msdn.microsoft.com/en-us/library/system.array.getlonglength.aspx" target="_blank">Array.GetLongLength</a> when the source is an array... but I don&#39;t <em>think</em> the current CLR supports arrays with more than Int32.MaxValue elements anyway, so it&#39;s a bit of a non-issue other than for future-proofing. Beyond that, I&#39;m not sure why the .NET implementation isn&#39;t optimized. It&#39;s not clear what an ICollection/ICollection&lt;T&gt; implementation is meant to return from its Count property if it has more than Int32.MaxValue elements anyway, to be honest.</p>  <p>Suggestions as to what I <em>should</em> have done are welcome... but I should probably point out that LongCount is more likely to be used against Queryable than Enumerable - it&#39;s easy to imagine a service representing a collection (such as a database table) which can quickly tell you the count even when it&#39;s very large. I would imagine that there are relatively few cases where you have a collection to evaluate in-process where you <em>really</em> just want to iterate through the whole lot just to get the count.</p>  <h3>Conclusion</h3>  <p>These are our first LINQ operators which return scalar values instead of sequences - with the natural consequence that they&#39;re simpler to understand in terms of control flow and timing. The methods simply execute - possibly with some optimization - and return their result. Nice and simple. Still, we&#39;ve seen there can still be a few interesting aspects to consider, including questions around optimization which don&#39;t necessarily have a good answer.</p>  <p>Next time, I think I&#39;ll implement Concat - mostly so that I can uncomment the overflow tests for Count. That&#39;s going back to an operator which returns a sequence, but it&#39;s a really simple one...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
