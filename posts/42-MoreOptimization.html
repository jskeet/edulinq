<html>
<head>
<title>Reimplementing LINQ to Objects: Part 42 - More optimization</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 42 - More optimization</h1>
<p>A few parts ago, I jotted down a few thoughts on optimization. Three more topics on that general theme have occurred to me, one of them prompted by the comments.</p>  <h3>User-directed optimizations</h3>  <p>I mentioned last time that for micro-optimization purposes, we could derive a tiny benefit if there were operators which allowed us to turn off potential optimizations - effectively declare in the LINQ query that we believed the input sequence would <em>never</em> be an IList&lt;T&gt; or an ICollection&lt;T&gt;, so it wasn&#39;t worth checking it. I still believe that level of optimization would be futile.</p>  <p>However, going the other way is entirely possible. Imagine if we could say, &quot;There are probably a lot of items in this collection, and the operations I want to perform on them are independent and thread-safe. Feel free to parallelize them.&quot;</p>  <p>That&#39;s exactly what Parallel LINQ gives you, of course. A simple call to AsParallel() somewhere in the query - often at the start, but it doesn&#39;t have to be - enables parallelism. You need to be careful how you use this, of course, which is why it&#39;s opt-in... and it gives you a fair amount of control in terms of degrees of potential parallelism, whether the results are required in the original order and so on.</p>  <p>In some ways my &quot;TopBy&quot; proposal is similar in a very small way, in that it gives information relatively early in the query, allowing the subsequent parts (ThenBy clauses) to take account of the extra information provided by the user. On the other hand, the effect is extremely localized - basically just for the sequence of clauses to do with ordering.</p>  <p>Related to the idea of parallelism is the idea of side-effects, and how they affect LINQ to Objects itself.</p>  <h3>Side-effects and optimization</h3>  <p>The optimizations in LINQ to Objects appear to make some assumptions about side-effects:</p>  <ul>   <li>Iterating over a collection won&#39;t cause any side-effects </li>    <li>Predicates <em>may</em> cause side-effects </li> </ul>  <p>Without the first point, all kinds of optimizations would effectively be inappropriate. As the simplest example, Count() won&#39;t use an iterator - it will just take the count of the collection. What if this was an odd collection which mutated something during iteration, though? Or what if accessing the Count property itself had side-effects? At that point we&#39;d be violating our principle of not changing observable behaviour by optimizing. Again, the optimizations are basically assuming &quot;sensible&quot; behaviour from collections.</p>  <p>There&#39;s a rather more subtle possible cause of side-effects which I&#39;ve never seen discussed. In some situations - most obviously Skip - an operator can be implemented to move over an iterator for a time without taking each &quot;current&quot; value. This is due to the separation of MoveNext() from Current. What if we were dealing with an iterator which had side-effects <em>only when Current was fetched</em>? It would be easy to write such a sequence - but again, I suspect there&#39;s an implicit assumption that such sequences simply don&#39;t exist, or that it&#39;s reasonable for the behaviour of LINQ operators with respect to them to be left unspecified.</p>  <p>Predicates, on the other hand, might not be so sensible. Suppose we were computing &quot;sequence.Last(x =&gt; 10 / x &gt; 1)&quot; on the sequence { 5, 0, 2 }. Iterating over the sequence forwards, we end up with a DivideByZeroException - whereas if we detected that the sequence was a list, and worked our way backwards from the end, we&#39;d see that 10 / 2 &gt; 1, and return that last element (2) immediately. Of course, exceptions aren&#39;t the only kind of side-effect that a predicate can have: it <em>could</em> mutate other state. However, it&#39;s generally easier to spot that and cry foul of it being a proper functional predicate than notice the possibility of an exception.</p>  <p>I believe this is the reason the predicated Last overload <em>isn&#39;t</em> optimized. It would be nice if these assumptions were documented, however.</p>  <h3>Assumptions about performance</h3>  <p>There&#39;s a final set of assumptions which the common ICollection&lt;T&gt;/IList&lt;T&gt; optimizations have all been making: that using the more &quot;direct&quot; members of the interfaces (specifically Count and the indexer) are more efficient than simply iterating. The interfaces make no such declarations: there&#39;s no requirement that Count <em>has</em> to be O(1), for example. Indeed, it&#39;s not even the case in the BCL. The first time you ask a &quot;view between&quot; on a sorted set for its count after the underlying set has changed, it has to count the elements again.</p>  <p>I&#39;ve had this problem before, <a href="http://msmvps.com/blogs/jon_skeet/archive/2010/07/29/there-s-a-hole-in-my-abstraction-dear-liza-dear-liza.aspx">removing items from a HashSet in Java</a>. The problem is that there&#39;s no way of communicating this information in a standardized way. We <em>could</em> use attributes for everything, but it gets very complicated, and I strongly suspect it would be a complete pain to use. Basically, performance is one area where abstractions just don&#39;t hold up - or rather, the abstractions aren&#39;t <em>designed</em> to include performance characteristics.</p>  <p>Even if we knew the complexity of (say) Count that still wouldn&#39;t help us necessarily. Suppose it&#39;s an O(n) operation - that sounds bad, until you discover that for this particular horrible collection, <em>each iteration step</em> is also O(n) for some reason. Or maybe there&#39;s a collection with an O(1) count but a <em>horrible</em> constant value, whereas iterating is really quick per item... so for small values of O(n), iteration would be faster. Then you&#39;ve got to bear in mind how much processor time is needed trying to work out the fastest approach... it&#39;s all bonkers.</p>  <p>So instead we make these assumptions, and for the most part they&#39;re correct. Just be aware of their presence.</p>  <h3>Conclusion</h3>  <p>I have reached the conclusion that I&#39;m tired, and need sleep. I might write about Queryable, IQueryable and query expressions next time.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
