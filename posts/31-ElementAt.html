<html>
<head>
<title>Reimplementing LINQ to Objects: Part 31 - ElementAt / ElementAtOrDefault</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 31 - ElementAt / ElementAtOrDefault</h1>
<p>A nice easy pair of operators tonight. I should possibly have covered them at the same time as First/Last/Single and the OrDefault variants, but never mind...</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb299233.aspx">ElementAt</a> and <a href="http://msdn.microsoft.com/en-us/library/bb494386.aspx">ElementAtOrDefault</a> have a single overload each:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource ElementAt&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource ElementAtOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index) </div>  <p>Isn&#39;t that blissfully simple after the overload storm of the past few days?</p>  <p>The two operators work in very similar ways:</p>  <ul>   <li>They use <em>immediate execution</em>. </li>    <li>The source parameter must not be null, and this is validated immediately. </li>    <li>They return the element at the specified zero-based index, if it&#39;s in the range 0 &lt;= index &lt; count. </li> </ul>  <p>The methods only differ in their handling of an index which falls outside the given bound. ElementAt will throw an ArgumentOutOfRangeException; ElementAtOrDefault will return the default value for TSource (e.g. 0, null, false). This is true even if index is negative. You might have expected some way to specify the default value to return if the index is out of bounds, but there isn&#39;t one. (This is consistent with FirstOrDefault() and so on, but not with Nullable&lt;T&gt;.GetValueOrDefault())</p>  <p>This behaviour leaves us some room for common code - for once I haven&#39;t used cut and paste for the implementation. Anyway, I&#39;m getting ahead of myself.</p>  <h3>What are we going to test?</h3>  <p>As you can imagine, my tests for the two operators are identical except for the expected result in the case of the index being out of range. I&#39;ve tested the following cases:</p>  <ul>   <li>Null source </li>    <li>A negative index </li>    <li>An index which is too big on a NonEnumerableCollection </li>    <li>An index which is too big on a NonEnumerableList </li>    <li>An index which is too big on a lazy sequence (using Enumerable.Range) </li>    <li>A valid index in a NonEnumerableList </li>    <li>A valid index in a lazy sequence </li> </ul>  <p>The &quot;non-enumerable&quot; list and collection are to test that the optimizations we&#39;re going to perform are working. In fact, the NonEnumerableCollection test fails on LINQ to Objects - it&#39;s only optimized for IList&lt;T&gt;. You&#39;ll see what I mean in a minute... and why that might not be a bad thing.</p>  <p>None of the tests are very interesting, to be honest.</p>  <h3>Let&#39;s implement it!</h3>  <p>As I mentioned earlier, I&#39;ve used some common code for once (although I admit the first implementation used cut and paste). As the only difference between the two methods is the handling of a particular kind of failure, I&#39;ve used the TryXXX pattern which exists elsewhere in the framework. There&#39;s a common method which <em>tries</em> to retrieve the right element as an out parameter, and indicates whether or not it succeeded via the return value. Not every kind of failure is just returned, of course - we want to throw an ArgumentNullException if source is null in either case.</p>  <p>That leaves our public methods looking quite straightforward:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource ElementAt&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index)     <br />{     <br />&#160;&#160;&#160; TSource ret;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (!TryElementAt(source, index, <span class="MethodParameter">out</span> ret))     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentOutOfRangeException(<span class="String">&quot;index&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource ElementAtOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index)     <br />{     <br />&#160;&#160;&#160; TSource ret;     <br />&#160;&#160;&#160; <span class="InlineComment">// We don&#39;t care about the return value - ret will be default(TSource) if it&#39;s false</span>     <br />&#160;&#160;&#160; TryElementAt(source, index, <span class="MethodParameter">out</span> ret);     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>TryElementAt will only return false if the index is out of bounds, so the exception is always appropriate. However, there is a disadvantage to this approach: we can&#39;t easily indicate in the exception message whether index was too large or negative. We could have specified a message which included the value of index itself, of course. I think it&#39;s a minor matter either way, to be honest.</p>  <p>The main body of the code is in TryElementAt, obviously. It would actually be very simple - just looping and counting up to index, checking as we went - except there are two potential optimizations.</p>  <p>The most obvious - and most profitable - optimization is if the collection implements IList&lt;T&gt;. If it does, we can efficiently obtain the count using the ICollection&lt;T&gt;.Count property (don&#39;t forget that IList&lt;T&gt; extends ICollection&lt;T&gt;), check that it&#39;s not too big, and then use the indexer from IList&lt;T&gt; to get straight to the right element. Brilliant! That&#39;s a clear win.</p>  <p>The less clear optimization is if the collection implements ICollection&lt;T&gt; but not IList&lt;T&gt;, or if it only implements the nongeneric ICollection. In those cases we can still get at the count - but we can&#39;t then get directly to the right element. In other words, we can optimize the <em>failure</em> case (possibly hugely), but at a very slight cost - the cost of checking whether the sequence implements either interface - for the success case, where the check won&#39;t do us any good.</p>  <p>This is the sort of optimization which is impossible to judge without real data. How often are these operators called with an invalid index? How often does that happen on a collection which implements ICollection&lt;T&gt; but not IList&lt;T&gt; (or implements ICollection)? How large are those collections (so how long would it take to have found our error the normal way)? What&#39;s the cost of performing the type check? I don&#39;t have the answers to <em>any</em> of these questions. I don&#39;t even have strong suspicions. I know that Microsoft doesn&#39;t use the same optimization, but I don&#39;t know whether that was due to hard data or a gut feeling.</p>  <p>For the moment, I&#39;ve kept all the optimizations. Here&#39;s the code:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> TryElementAt&lt;TSource&gt;(    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; <span class="ValueType">int</span> index,    <br />&#160;&#160;&#160; <span class="MethodParameter">out</span> TSource element)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; element = <span class="Modifier">default</span>(TSource);    <br />&#160;&#160;&#160; <span class="Statement">if</span> (index &lt; 0)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; collection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;    <br />&#160;&#160;&#160; <span class="Statement">if</span> (collection != <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> count = collection.Count;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (index &gt;= count)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// If it&#39;s a list, we know we&#39;re okay now - just return directly...</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IList&lt;TSource&gt; list = source <span class="Keyword">as</span> IList&lt;TSource&gt;;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (list != <span class="Keyword">null</span>)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; element = list[index];    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />    <br />&#160;&#160;&#160; ICollection nonGenericCollection = source <span class="Keyword">as</span> ICollection;    <br />&#160;&#160;&#160; <span class="Statement">if</span> (nonGenericCollection != <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> count = nonGenericCollection.Count;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (index &gt;= count)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="InlineComment">// We don&#39;t need to fetch the current value each time - get to the right</span>    <br />&#160;&#160;&#160; <span class="InlineComment">// place first.</span>    <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Note use of -1 so that we start off my moving onto element 0.</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Don&#39;t want to use i &lt;= index in case index == int.MaxValue!</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = -1; i &lt; index; i++)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; element = iterator.Current;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;    <br />&#160;&#160;&#160; }    <br />} </div>  <p>As you can see, the optimized cases actually form the bulk of the code - part of me thinks it would be worth removing the non-IList&lt;T&gt; optimizations just for clarity and brevity.</p>  <p>It&#39;s worth looking at the &quot;slow&quot; case where we actually iterate. The for loop looks odd, until you think that to get at element 0, you have to call MoveNext() once. We don&#39;t want to just add one to index or use a less-than-or-equal condition: both of those would fail in the case where index is int.MaxValue; we&#39;d either not loop at all (by incrementing index and it overflowing either causing an exception or becoming negative) or we&#39;d loop forever, as <em>every</em> int is less than or equal to int.MaxValue.</p>  <p>Another way to look at it is that the loop counter (&quot;i&quot;) is the &quot;current index&quot; within the iterator: the iterator starts before the first element, so it&#39;s reasonable to start at -1.</p>  <p>The reason I&#39;m drawing attention to this is that I got all of this wrong first time... and was very grateful for unit tests to catch me out.</p>  <h3>Conclusion</h3>  <p>For me, the most interesting part of ElementAt is the decision about optimization. I&#39;m sure I&#39;m not the only one who optimizes without data at times - but it&#39;s a dangerous thing to do. The problem is that this isn&#39;t the normal micro-optimization quandary of &quot;it&#39;s always a tiny bit better, but it&#39;s probably insignificant and makes the code harder to read&quot;. For the cases where this is faster, it could make an enormous difference - asking for element one million of a linked list which doesn&#39;t <em>quite</em> have enough elements could be very painful. But do failure cases need to be fast? How common are they? As you can tell, I&#39;m dithering. I think it&#39;s at least worth thinking about what optimizations <em>might</em> make a difference - even if we later remove them.</p>  <p>Next time, I think I&#39;ll tackle Contains - an operator which you might expect to be really fast on a HashSet&lt;T&gt;, but which has some interesting problems of its own...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
