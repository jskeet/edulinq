<html>
<head>
<title>Reimplementing LINQ to Objects: Part 15 - Union</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 15 - Union</h1>
<p>I&#39;m continuing the set-based operators with Union. I may even have a couple of hours tonight - possibly enough to finish off Intersect and Except as well... let&#39;s see.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.union.aspx" target="_blank">Union</a> is another extension method with two overloads; one taking an equality comparer and one just using the default:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Union&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Union&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer) </div>  <p>This &quot;two overloads, one taking an equality comparer&quot; pattern is familiar from Distinct; we&#39;ll see that and Intersect and Except do exactly the same thing.</p>  <p>Simply put, Union returns the union of the two sequences - all items that are in either input sequence. The result sequence has no duplicates in even if one of the input sequences contains duplicates. (I&#39;m using the term &quot;duplicate&quot; here to mean an element which is equal to another according to the equality comparer we&#39;re using in the operator.)</p>  <p>Characteristics:</p>  <ul>   <li>Union uses deferred execution: argument validation is basically all that happens when the method is first called; it only starts iterating over the input sequences when you iterate over the result sequence </li>    <li>Neither first nor second can be null; the comparer argument <em>can</em> be null, in which case the default equality comparer is used </li>    <li>The input sequences are only read as and when they&#39;re needed; to return the first result element, only the first input element is read </li> </ul>  <p>It&#39;s worth noting that the documentation for Union specifies a lot more than the Distinct documentation does:</p>  <blockquote>   <p>When the object returned by this method is enumerated, Union enumerates first and second in that order and yields each element that has not already been yielded.</p> </blockquote>  <p>To me, that actually looks like a <em>guarantee</em> of the rules I proposed for Distinct. In particular, it&#39;s guaranteeing that the implementation iterates over &quot;first&quot; before &quot;second&quot;, and if it&#39;s yielding elements as it goes, that guarantees that distinct elements will retain their order from the original input sequences. Whether others would read it in the same way or not, I can&#39;t say... input welcome.</p>  <h3>What are we going to test?</h3>  <p>I&#39;ve written quite a few tests for Union - possibly more than we really <em>need</em>, but they demonstrate a few points of usage. The tests are:</p>  <ul>   <li>Arguments are validated eagerly </li>    <li>Finding the union of two sequences without specifying a comparer; both inputs have duplicate elements, and there&#39;s one element in both </li>    <li>The same test as above but explicitly specifying null as the comparer, to force the default to be used </li>    <li>The same test as above but using a case-insensitive string comparer </li>    <li>Taking the union of an empty sequence with a non-empty one </li>    <li>Taking the union of a non-empty sequence with an empty one </li>    <li>Taking the union of two empty sequences </li>    <li>Proving that the first sequence isn&#39;t used until we start iterating over the result sequence (using ThrowingEnumerable) </li>    <li>Proving that the second sequence isn&#39;t used until we&#39;ve exhausted the first </li> </ul>  <p>No new collections or comparers needed this time though - it&#39;s all pretty straightforward. I haven&#39;t written any tests for null elements this time - I&#39;m convinced enough by what I saw when implementing Distinct to believe they won&#39;t be a problem.</p>  <h3>Let&#39;s implement it!</h3>  <p>First things first: we can absolutely implement the simpler overload in terms of the more complex one, and I&#39;ll do the same for Except and Intercept. Here&#39;s the Union method:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Union&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> Union(first, second, EqualityComparer&lt;TSource&gt;.Default);     <br />} </div>  <p>So how do we implement the more complex overload? Well, I&#39;ve basically been a bit disappointed by Union in terms of its conceptual weight. It doesn&#39;t really give us anything that the obvious combination of Concat and Distinct doesn&#39;t - so let&#39;s implement it that way first:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Union&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> first.Concat(second).Distinct(comparer);     <br />} </div>  <p>The argument validation can be implemented by Concat with no problems here - the parameters have the same name, so any exceptions thrown will be fine in every way.</p>  <p>That&#39;s how I <em>think</em> about Union, but as I&#39;ve mentioned before, I&#39;d rather not actually see Concat and Distinct showing up in the stack trace - so here&#39;s the fuller implementation.</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Union&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (first == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;first&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">if</span> (second == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;second&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> UnionImpl(first, second, comparer ?? EqualityComparer&lt;TSource&gt;.Default);    <br />}    <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; UnionImpl&lt;TSource&gt;(    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{    <br />&#160;&#160;&#160; HashSet&lt;TSource&gt; seenElements = <span class="Keyword">new</span> HashSet&lt;TSource&gt;(comparer);    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> first)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (seenElements.Add(item))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> second)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (seenElements.Add(item))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />} </div>  <p>That feels like an absurd waste of code when we can achieve the same result so simply, admittedly. This is the first time my resolve against implementing one operator in terms of completely different ones has wavered. Just looking at it in black and white (so to speak), I&#39;m close to going over the edge...</p>  <h3>Conclusion</h3>  <p>Union was a disappointingly bland operator in my view. (Maybe I should start awarding operators marks out of ten for being interesting, challenging etc.) It doesn&#39;t feel like it&#39;s really earned its place in LINQ, as calls to Concat/Distinct can replace it so easily. Admittedly as I&#39;ve mentioned in several other places, a lot of operators can be implemented in terms of each other - but rarely <em>quite</em> so simply.</p>  <p>Still, I think Intersect and Except should be more interesting.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
