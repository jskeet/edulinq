<html>
<head>
<title>Reimplementing LINQ to Objects: Part 32 - Contains</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 32 - Contains</h1>
<p>After the dubious optimizations of ElementAt/ElementAtOrDefault yesterday, we meet an operator which is remarkably good at defying optimization. Sort of. Depending on how you feel it should behave.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.contains.aspx">Contains</a> has two overloads, which only differ by whether or not they take an equality comparer - just like Distinct, Intersect and the like:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Contains&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource value)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Contains&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource value,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer) </div>  <p>The operator simply returns a Boolean indicating whether or not &quot;value&quot; was found in &quot;source&quot;. The salient points of its behaviour should be predictable now:</p>  <ul>   <li>It uses immediate execution (as it&#39;s returning a simple value instead of a sequence) </li>    <li>The source parameter cannot be null, and is validated immediately </li>    <li>The value parameter <em>can</em> be null: it&#39;s valid to search for a null value within a sequence </li>    <li>The comparer parameter can be null, which is equivalent to passing in EquailtyComparer&lt;TSource&gt;.Default. </li>    <li>The overload without a comparer uses the default equality comparer too. </li>    <li>If a match is found, the method returns immediately without reading the rest of the input sequence. </li>    <li>There&#39;s a documented optimization for ICollection&lt;T&gt; - but there are significant issues with it... </li> </ul>  <p>So far, so good.</p>  <h3>What are we going to test?</h3>  <p>Aside from argument validation, I have tests for the value being present in the source, and it <em>not</em> being present in the source... for the three options of &quot;no comparer&quot;, &quot;null comparer&quot; and &quot;specific comparer&quot;.</p>  <p>I then have one final test to validate that we return as soon as we&#39;ve found a match, by giving a query which will blow up when the element after the match is computed.</p>  <p>Frankly none of the tests are earth-shattering, but in the spirit of giving you an idea of what they&#39;re like, here&#39;s one with a custom comparer - we use the same source and value for a &quot;default comparer&quot; test which <em>doesn&#39;t</em> find the value as the case differs:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> MatchWithCustomComparer()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Default equality comparer is ordinal</span>     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] source = { <span class="String">&quot;foo&quot;</span>, <span class="String">&quot;bar&quot;</span>, <span class="String">&quot;baz&quot;</span> };     <br />&#160;&#160;&#160; Assert.IsTrue(source.Contains(<span class="String">&quot;BAR&quot;</span>, StringComparer.OrdinalIgnoreCase));     <br />} </div>  <p>Currently I <em>don&#39;t</em> have a test for the optimization mentioned in the bullet points above, as I believe it&#39;s broken. More later.</p>  <h3>Let&#39;s implement it!</h3>  <p>To start with, let&#39;s dispense with the overload without a comparer parameter: that just delegates to the other one by specifying EqualityComparer&lt;TSource&gt;.Default. Trivial. (Or so we might think. There&#39;s more to this than meets the eye.)</p>  <p>I&#39;ve got three implementations, but we&#39;ll start with just two of them. Which one you pick would depend on whether you&#39;re happy to use one operator to implement another. If you think that&#39;s okay, it&#39;s really simple:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Contains&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource value,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)     <br />{     <br />&#160;&#160;&#160; comparer = comparer ?? EqualityComparer&lt;TSource&gt;.Default;     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Any(item =&gt; comparer.Equals(value, item));     <br />} </div>  <p>&quot;Any&quot; has exactly the traits we want, including validation of the non-nullity of &quot;source&quot;. It&#39;s hardly complicated code if we <em>don&#39;t</em> use Any though:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Contains&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource value,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; comparer = comparer ?? EqualityComparer&lt;TSource&gt;.Default;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (comparer.Equals(value, item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />} </div>  <p>Obviously there&#39;s a <em>slight</em> penalty in using Any just because of executing a delegate on each iteration - and the extra memory requirement of building an object to capture the comparer. I haven&#39;t measured the performance impact of this - again, it&#39;s a candidate for benchmarking.</p>  <h3>Can&#39;t we optimize? (And why does LINQ to Objects think it can?)</h3>  <p>The implementations above are all very well, but they feel ever so simplistic. With ElementAt, we were able to take advantage of the fact that an IList&lt;T&gt; allows us random access by index. Surely we&#39;ve got similar collections which allow us to test for containment cheaply?</p>  <p>Well, yes and no. We&#39;ve got IDictionary&lt;TKey, TValue&gt; which allows you to check for the presence of a particular <em>key</em> - but even it would be hard to test whether the sequence we&#39;re looking at is the key sequence for some IDictionary&lt;TSource, TValue&gt;, and somehow get back to the dictionary.</p>  <p>ICollection&lt;T&gt; has a Contains method, but that doesn&#39;t necessarily do the right thing. This is particularly troubling, as the <a href="http://msdn.microsoft.com/en-us/library/bb352880.aspx">MSDN documentation for the comparer-less overload</a> has contradictory information:</p>  <blockquote>   <p>(Summary)</p>    <p>Determines whether a sequence contains a specified element by using the default equality comparer.</p>    <p>(Remarks)</p>    <p>If the type of source implements ICollection&lt;T&gt;, the <strong>Contains</strong> method in that implementation is invoked to obtain the result. Otherwise, this method determines whether source contains the specified element.</p>    <p>Enumeration is terminated as soon as a matching element is found.</p>    <p>Elements are compared to the specified value by using the default equality comparer, Default.</p> </blockquote>  <p>Why is this troubling? Well, let&#39;s look at a test:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SetWithDifferentComparer()     <br />{     <br />&#160;&#160;&#160; HashSet&lt;<span class="ReferenceType">string</span>&gt; sourceAsSet = <span class="Keyword">new</span> HashSet&lt;<span class="ReferenceType">string</span>&gt;(StringComparer.OrdinalIgnoreCase)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; { <span class="String">&quot;foo&quot;</span>, <span class="String">&quot;bar&quot;</span>, <span class="String">&quot;baz&quot;</span> };     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ReferenceType">string</span>&gt; sourceAsSequence = sourceAsSet;     <br />&#160;&#160;&#160; Assert.IsTrue(sourceAsSet.Contains(<span class="String">&quot;BAR&quot;</span>));     <br />&#160;&#160;&#160; Assert.IsFalse(sourceAsSequence.Contains(<span class="String">&quot;BAR&quot;</span>));     <br />&#160;&#160;&#160; Assert.IsFalse(sourceAsSequence.Contains(<span class="String">&quot;BAR&quot;</span>, StringComparer.Ordinal));     <br />} </div>  <p>(This exact code won&#39;t build in the Edulinq project configuration, as that doesn&#39;t have a reference to the System.Core assembly which contains HashSet&lt;T&gt;. I&#39;ve got a hack which allows me to run <em>effectively</em> this code though. See the source for details.)</p>  <p>Now this test looks correct to me: while we&#39;re regarding the set <em>as</em> a set, it should use the set&#39;s comparer and find &quot;BAR&quot; with a case-insensitive match. However, when we use it as a <em>sequence</em> in LINQ, it should obey the rules of Enumerable.Contains - which means that the middle call should use the default equality comparer for string. Under that equality comparer, &quot;BAR&quot; <em>isn&#39;t</em> present.</p>  <p>It doesn&#39;t: the above test fails on that middle call in LINQ to Objects, because HashSet&lt;T&gt; implements ICollection&lt;T&gt;. To fit in with the implementation, the documentation summary should actually be worded as something like:</p>  <p>&quot;Determines whether a sequence contains a specified element by using the default equality comparer if the sequence doesn&#39;t implement ICollection&lt;T&gt;, or whatever equality comparison the collection uses if it <em>does</em> implement ICollection&lt;T&gt;.&quot;</p>  <p>Now you may be saying to yourself that this is only like relying on IList&lt;T&gt; to fetch an item by index in a fashion consistent with iterating over with it - but I&#39;d argue that any IList&lt;T&gt; implementation which <em>didn&#39;t</em> do that was simply broken... whereas <a href="http://msdn.microsoft.com/en-us/library/k5cf1d56.aspx">ICollection&lt;T&gt;.Contains</a> is specifically documented to allow custom comparisons:</p>  <blockquote>   <p>Implementations can vary in how they determine equality of objects; for example, List&lt;T&gt; uses Comparer&lt;T&gt;.Default, whereas Dictionary&lt;TKey, TValue&gt; allows the user to specify the IComparer&lt;T&gt; implementation to use for comparing keys.</p> </blockquote>  <p>Let&#39;s leave aside the fact that those &quot;Comparer&lt;T&gt;&quot; and &quot;IComparer&lt;T&gt;&quot; should be &quot;EqualityComparer&lt;T&gt;&quot; and &quot;IEqualityComparer&lt;T&gt;&quot; respectively for the minute, and just note that it&#39;s entirely reasonable for an implementation <em>not</em> to use the default equality comparer. That makes sense - but I believe it also makes sense for source.Contains(value) to be more predictable in terms of the equality comparer it uses.</p>  <p>Now I would certainly agree that having a method call which changes semantics based on whether the compile-time type of the source is IEnumerable&lt;T&gt; or ICollection&lt;T&gt; is undesirable too... but I&#39;m not sure there <em>is</em> any particularly nice solution. The options are:</p>  <ul>   <li>The current LINQ to Objects implementation where the comparer used is hard to predict. </li>    <li>The Edulinq implementation where the type&#39;s default comparer is always used... <em>if</em> the compile-time type means that Enumerable.Contains is used in the first place. </li>    <li>Remove the comparer-less overload entirely, and force people to specify one. This is lousy for convenience. </li> </ul>  <p>Note that you might expect the overload which takes a comparer to work the same way if you pass in null as the comparer - but it doesn&#39;t. That overload <em>never</em> delegates to ICollection&lt;T&gt;.Contains.</p>  <p>So: convenience, predictability, consistency. Pick any two. Isn&#39;t API design fun? This isn&#39;t even thinking about performance, of course...</p>  <p>It&#39;s worth bearing in mind that even the current behaviour which is presumably meant to encourage consistency doesn&#39;t work. One might expect that the following would always be equivalent for any sensible collection:</p>  <div class="code"><span class="Linq">var</span> first = source.Contains(value);     <br /><span class="Linq">var</span> second = source.Select(x =&gt; x).Contains(value); </div>  <p>... but of course the second line will always use EqualityComparer&lt;T&gt;.Default whereas the first may or may not.</p>  <p>(Just for fun, think about Dictionary&lt;TKey, TValue&gt; which implements ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;; its explicitly-implemented ICollection&lt;T&gt;.Contains method will use its own equality comparer for the key, but the default equality comparer for the value part of the pair. Yay!)</p>  <h3>So can we <em>really</em> not optimize?</h3>  <p>I can think of exactly one situation which we could legitimately optimize without making the behaviour hard to predict. Basically we&#39;re fine to ask the collection to do our work for us if we can guarantee it will use the right comparer. Ironically, List&lt;T&gt;.Contains has an overload which allows us to specify the equality comparer, so we <em>could</em> delegate to that - but it&#39;s not going to be significantly faster than doing it ourselves. It&#39;s still got to look through everything.</p>  <p><a href="http://msdn.microsoft.com/en-us/library/dd412081.aspx">ISet&lt;T&gt;</a> in .NET 4 doesn&#39;t help us much - its API doesn&#39;t talk about equality comparers. (This makes a certain amount of sense - consider <a href="http://msdn.microsoft.com/en-us/library/dd412070.aspx">SortedSet&lt;T&gt;</a> which uses IComparer&lt;T&gt; instead of IEqualityComparer&lt;T&gt;. It wouldn&#39;t make sense to ask a SortedSet&lt;T&gt; for an equality comparer - it couldn&#39;t give you one, as it wouldn&#39;t know how to produce a hash code.)</p>  <p>However, HashSet&lt;T&gt; <em>does</em> give us something to work with. You can <em>ask</em> a HashSet&lt;T&gt; which equality comparer it uses, so we could delegate to its implementation <em>if and only if it would use the one we&#39;re interested in</em>. We can bolt that into our existing implementation pretty easily, after we&#39;ve worked out the comparer to use:</p>  <div class="code">HashSet&lt;TSource&gt; hashSet = source <span class="Keyword">as</span> HashSet&lt;TSource&gt;;     <br /><span class="Statement">if</span> (hashSet != <span class="Keyword">null</span> &amp;&amp; comparer.Equals(hashSet.Comparer))     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> hashSet.Contains(value);     <br />} </div>  <p>So is this worth including or not?</p>  <p>Pros:</p>  <ul>   <li>It covers one of the biggest use cases for optimizing Contains; I <em>suspect</em> this is used more often than the LINQ implementation of Contains working over a dictionary. </li>    <li>So long as the comparer doesn&#39;t override Equals in a bizarre way, it should be a true optimization with no difference in behaviour. </li>    <li>The optimization is applied for <em>both</em> overloads of Enumerable.Contains, not just the comparer-less one. </li> </ul>  <p>Cons:</p>  <ul>   <li>It&#39;s specific to HashSet&lt;T&gt; rather than an interface type. That makes it feel a little too specific to be a good target of optimization. </li>    <li>We&#39;ve still got the issue of consistency in terms of sourceAsSet.Contains(value) vs sourceAsSequence.Contains(value) </li>    <li>There&#39;s a tiny bit of overhead if the source isn&#39;t a hash set, and a further overhead if it <em>is</em> a hash set but with the wrong comparer. I&#39;m not too bothered about this. </li> </ul>  <p>It&#39;s not the default implementation in Edulinq at the moment, but I could possibly be persuaded to include it. Likewise I have a conditionally-compiled version of Contains which <em>is</em> compatible with LINQ to Objects, with the &quot;broken&quot; optimization for the comparer-less overload; this is turned off by default too.</p>  <h3>Conclusion</h3>  <p>Gosh! I hadn&#39;t expected Contains to be <em>nearly</em> this interesting. I&#39;d worked out that optimization would be a pain, but I hadn&#39;t expected it to be such a weird design choice.</p>  <p>This is the first time I&#39;ve deliberately gone against the LINQ to Objects behaviour, other than the MS bug around descending orderings using &quot;extreme&quot; comparers. The option for compatibility is there, but I feel fairly strongly that this was a bad design decision on Microsoft&#39;s part. A bad decision out of some fairly unpleasant alternatives, I grant you. I&#39;m willing to be persuaded of its virtues, of course - and in particular I&#39;d welcome discussion with the LINQ team around this. In particular, it&#39;s always fun to hear about the history of design decisions.</p>  <p>Next up, Cast and OfType.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
