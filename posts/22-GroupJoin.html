<html>
<head>
<title>Reimplementing LINQ to Objects: Part 22 - GroupJoin</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 22 - GroupJoin</h1>
<p>Another operator that was decidedly easy to implement - partly as I was able to just adapt everything from Join, including the tests. 15 minutes for tests + implementation... and no doubt considerably long writing it up.</p>  <h3>What is it?</h3>  <p>After the complexity of GroupBy, <a href="http://msdn.microsoft.com/en-us/library/bb358101.aspx">GroupJoin</a> has a refreshingly small list of overloads:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer) </div>  <p>We can essentially ignore the first overload in the normal way - it just uses the default equality comparer for TKey. (You&#39;ll be pleased to hear that I think we&#39;re coming towards the end of the operators which use equality comparers, so I won&#39;t need to repeat that sort of sentence many more times.)</p>  <p>The best way to get to grips with what GroupJoin does is to think of Join. There, the overall idea was that we looked through the &quot;outer&quot; input sequence, found all the matching items from the &quot;inner&quot; sequence (based on a key projection on each sequence) and then yielded pairs of matching elements. GroupJoin is similar, except that instead of yielding pairs of elements, it yields a single result for each &quot;outer&quot; item based on that item and the sequence of matching &quot;inner&quot; items.</p>  <p>The fact that a result is yielded for <em>every</em> outer item is important: even if there are <em>no</em> matches, a result is still returned, just with an empty sequence. I&#39;ll come back to that later, thinking about &quot;left joins&quot;.</p>  <p>In terms of deferred execution, input consumption etc, GroupJoin behaves very much like Join:</p>  <ul>   <li>Arguments are validated eagerly: everything other than comparer has to be non-null </li>    <li>It uses deferred execution </li>    <li>When you start iterating over the result, the &quot;inner&quot; sequence is immediately read all the way through </li>    <li>The &quot;outer&quot; sequence is streamed: each time you read an item from the result sequence, one item from the outer sequence is read </li> </ul>  <h3>What are we going to test?</h3>  <p>To be absolutely honest, I cribbed the tests from Join, and just adapted the resultSelector and the expected results. It&#39;s simple enough to do: I was already using string concatenation to piece together the two items (outer and inner) for the Join tests; for GroupJoin I&#39;ve just modified that to use string.Join (<em>not</em> the same as Enumerable.Join!) to build a semi-colon string delimited string of all the inner matches for that particular outer element.</p>  <p>Here&#39;s a sample test, in both the Join and GroupJoin versions:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SimpleJoin()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// We&#39;re going to join on the first character in the outer sequence item</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// being equal to the second character in the inner sequence item</span>     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] outer = { <span class="String">&quot;first&quot;</span>, <span class="String">&quot;second&quot;</span>, <span class="String">&quot;third&quot;</span> };     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;essence&quot;</span>, <span class="String">&quot;offer&quot;</span>, <span class="String">&quot;eating&quot;</span>, <span class="String">&quot;psalm&quot;</span> };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = outer.Join(inner,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; outerElement =&gt; outerElement[0],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; innerElement =&gt; innerElement[1],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (outerElement, innerElement) =&gt; outerElement + <span class="String">&quot;:&quot;</span> + innerElement);     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Note: no matches for &quot;third&quot;</span>     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;first:offer&quot;</span>, <span class="String">&quot;second:essence&quot;</span>, <span class="String">&quot;second:psalm&quot;</span>);     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SimpleGroupJoin()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// We&#39;re going to join on the first character in the outer sequence item</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// being equal to the second character in the inner sequence item</span>     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] outer = { <span class="String">&quot;first&quot;</span>, <span class="String">&quot;second&quot;</span>, <span class="String">&quot;third&quot;</span> };     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;essence&quot;</span>, <span class="String">&quot;offer&quot;</span>, <span class="String">&quot;eating&quot;</span>, <span class="String">&quot;psalm&quot;</span> };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = outer.GroupJoin(inner,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; outerElement =&gt; outerElement[0],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; innerElement =&gt; innerElement[1],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (outerElement, innerElements) =&gt; outerElement + <span class="String">&quot;:&quot;</span> + <span class="ReferenceType">string</span>.Join(<span class="String">&quot;;&quot;</span>, innerElements));     <br />    <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;first:offer&quot;</span>, <span class="String">&quot;second:essence;psalm&quot;</span>, <span class="String">&quot;third:&quot;</span>);     <br />} </div>  <p>Note how the match sequence for &quot;first&quot; contained only a single element and the match sequence for &quot;second&quot; contains two elements. There were no matches for &quot;third&quot;, but we still get a result, just with an empty match sequence.</p>  <h3>Let&#39;s implement it!</h3>  <p>I was able to copy the implementation from Join as well, pretty much - I only had to simplify it to yield a single value instead of using a foreach loop.</p>  <p>Obviously the comparer-free overload calls into the one with the comparer, which then validates the arguments and calls into an iterator block method. If you&#39;ve read all the rest of the posts in this series, you don&#39;t need to see that yet again - and if you haven&#39;t, just go back and look at some. So, what does the iterator block do? It uses a lookup again. It builds a lookup from the inner sequence, and then we just have to iterate over the outer sequence, applying resultSelector to each &quot;outer element / matching inner element sequence&quot; pair:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupJoinImpl&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = inner.ToLookup(innerKeySelector, comparer);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="Linq">var</span> outerElement <span class="Statement">in</span> outer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">var</span> key = outerKeySelector(outerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> resultSelector(outerElement, lookup[key]);     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Yup, Lookup makes things so simple it almost hurts... and that&#39;s without even trying hard. I&#39;m sure we could pay some more attention to the design of Lookup and Grouping if we really wanted to. (I may revisit them later... they&#39;re clearly working for us at the moment.)</p>  <h3>Query expressions and left joins</h3>  <p>C# has direct support for GroupJoin when you use the &quot;join ... into&quot; syntax. Note that despite the use of &quot;into&quot; this is <em>not</em> a <a href="http://msmvps.com/blogs/jon_skeet/archive/2010/09/15/query-expression-syntax-continuations.aspx">query continuation</a>. Instead, it&#39;s just a way of giving a name to all the matches in the join. Here&#39;s an example, finding all the words of a given length:</p>  <div class="code"><span class="ValueType">int</span>[] outer = { 5, 3, 7 };     <br /><span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;bee&quot;</span>, <span class="String">&quot;giraffe&quot;</span>, <span class="String">&quot;tiger&quot;</span>, <span class="String">&quot;badger&quot;</span>, <span class="String">&quot;ox&quot;</span>, <span class="String">&quot;cat&quot;</span>, <span class="String">&quot;dog&quot;</span> };     <br />    <br /><span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> outer     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">join</span> y <span class="Statement">in</span> inner <span class="Linq">on</span> x <span class="Linq">equals</span> y.Length <span class="Linq">into</span> matches     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x + <span class="String">&quot;:&quot;</span> + <span class="ReferenceType">string</span>.Join(<span class="String">&quot;;&quot;</span>, matches);     <br />    <br />query.AssertSequenceEqual(<span class="String">&quot;5:tiger&quot;</span>, <span class="String">&quot;3:bee;cat;dog&quot;</span>, <span class="String">&quot;7:giraffe&quot;</span>); </div>  <p>Note that whereas in a simple &quot;join&quot; syntax, the &quot;y&quot; range variable would be available for the rest of the query, this time it&#39;s only &quot;matches&quot; that&#39;s available - basically &quot;y&quot; is only used to express the key selector (y.Length in this case).</p>  <p>Now think about <a href="http://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join">left joins</a> (or left outer joins) from SQL. From the linked Wikipedia page:</p>  <blockquote>   <p>The result of a <i>left outer join</i> (or simply <b>left join</b>) for table A and B always contains all records of the &quot;left&quot; table (A), even if the join-condition does not find any matching record in the &quot;right&quot; table (B). This means that if the <code>ON</code> clause matches 0 (zero) records in B, the join will still return a row in the resultâ€”but with NULL in each column from B.</p> </blockquote>  <p>So, how can we mimic this? Well, we could just use GroupJoin directly, and deal with the fact that if there are no matches, the match sequence will be empty. That&#39;s not quite like a left join though - it doesn&#39;t capture the idea of getting a null value for the unmatched result. We can use DefaultIfEmpty for that quite easily though. Here&#39;s an example adapted from the one above, where I introduce 4 into the outer sequence. There are no animals with 4 letters in the inner list, so for that item we end up with no values. I&#39;ve used DefaultIfEmpty to make sure that we <em>do</em> get a value - and just to make it show up, I&#39;ve specified a default value of the string literal &quot;null&quot; rather than just a null reference. Here&#39;s the test, including the results:</p>  <div class="code"><span class="ValueType">int</span>[] outer = { 5, 3, 4, 7 };     <br /><span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;bee&quot;</span>, <span class="String">&quot;giraffe&quot;</span>, <span class="String">&quot;tiger&quot;</span>, <span class="String">&quot;badger&quot;</span>, <span class="String">&quot;ox&quot;</span>, <span class="String">&quot;cat&quot;</span>, <span class="String">&quot;dog&quot;</span> };     <br />    <br /><span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> outer     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">join</span> y <span class="Statement">in</span> inner <span class="Linq">on</span> x <span class="Linq">equals</span> y.Length <span class="Linq">into</span> matches     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x + <span class="String">&quot;:&quot;</span> + <span class="ReferenceType">string</span>.Join(<span class="String">&quot;;&quot;</span>, matches.DefaultIfEmpty(<span class="String">&quot;null&quot;</span>));     <br />    <br />query.AssertSequenceEqual(<span class="String">&quot;5:tiger&quot;</span>, <span class="String">&quot;3:bee;cat;dog&quot;</span>, <span class="String">&quot;4:null&quot;</span>, <span class="String">&quot;7:giraffe&quot;</span>); </div>  <p>Okay, that&#39;s getting closer... but we still need to deal with a whole sequence of results at a time. A normal left join still gives pairs of results... can we mimic <em>that</em>? Absolutely - just use GroupJoin and then SelectMany, represented in query expressions as a second &quot;from&quot; clause:</p>  <div class="code"><span class="ValueType">int</span>[] outer = { 5, 3, 4, 7 };    <br /><span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;bee&quot;</span>, <span class="String">&quot;giraffe&quot;</span>, <span class="String">&quot;tiger&quot;</span>, <span class="String">&quot;badger&quot;</span>, <span class="String">&quot;ox&quot;</span>, <span class="String">&quot;cat&quot;</span>, <span class="String">&quot;dog&quot;</span> };    <br />    <br /><span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> outer    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">join</span> y <span class="Statement">in</span> inner <span class="Linq">on</span> x <span class="Linq">equals</span> y.Length <span class="Linq">into</span> matches    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">from</span> z <span class="Statement">in</span> matches.DefaultIfEmpty(<span class="String">&quot;null&quot;</span>)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x + <span class="String">&quot;:&quot;</span> + z;    <br />query.AssertSequenceEqual(<span class="String">&quot;5:tiger&quot;</span>, <span class="String">&quot;3:bee&quot;</span>, <span class="String">&quot;3:cat&quot;</span>, <span class="String">&quot;3:dog&quot;</span>, <span class="String">&quot;4:null&quot;</span>, <span class="String">&quot;7:giraffe&quot;</span>); </div>  <p>That&#39;s now genuinely close to what a SQL left join would do.</p>  <h3>Conclusion</h3>  <p>That&#39;s it for joins, I believe. I&#39;m so glad I implemented ToLookup first - it made everything else trivial. Next up, I think we&#39;ll look at Take/TakeWhile/Skip/SkipWhile, which should be pleasantly simple.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
