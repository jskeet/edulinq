<html>
<head>
<title>Reimplementing LINQ to Objects: Part 44 - Aspects of Design</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 44 - Aspects of Design</h1>
<p>I promised a post on some questions of design that are raised by LINQ to Objects. I suspect that most of these have already been covered in other posts, but it may well be helpful to talk about them here too. This time I&#39;ve thought about it particularly from the point of view of how other APIs can be built on some of the same design principles, and the awkward choices that LINQ has thrown up.</p>  <h3>The power of composability and immutability</h3>  <p>Perhaps the most important aspect of LINQ which I&#39;d love other API designers to take on board is that of how complicated queries are constructed from lots of little building blocks. What makes it particularly elegant is that the result of applying each building block is unchanged by anything else you do to it afterwards.</p>  <p>LINQ doesn&#39;t <em>enforce</em> immutability of course - you can start off with a mutable list and change its content at any time, for example, or change the properties of one of the objects referenced within it, or pass in a delegate with side-effects - but <em>LINQ itself</em> won&#39;t introduce side-effects.</p>  <p>The Task-based Asynchronous Pattern takes a similar approach, allowing composable building blocks of tasks. I&#39;ve seen this pattern in various guises over the years - if you find yourself thinking in terms of a pipeline of some kind, it may well be appropriate, especially if each state in the pipeline emits the same type as it consumes.</p>  <p>General immutability is a somewhat different design trait of course, but one which can make <em>such</em> a difference. The java.util.{Date,Calendar} classes are horrible, not least because they&#39;re mutable - you can never stash a value away without being concerned that it may get changed by something else. <a href="http://joda-time.sf.net">Joda Time</a> has <em>some</em> mutable implementations, but typically the immutable classes are used in a fluent way. Of course, .NET uses value types for various core types to start with, but also makes TimeZoneInfo immutable. For genuine &quot;values&quot; I would highly encourage API designers to at least <em>strongly consider</em> immutable types. They&#39;re not <em>always</em> appropriate by any means, but they can be hugely useful where they fit nicely.</p>  <h3>Extension methods on interfaces</h3>  <p>It&#39;s no surprise that extension methods are heavily used in LINQ, given that they were effectively introduced into the language in order to enable LINQ in the first place. However, they do work particularly well with interfaces as a way of adding common behaviour.</p>  <p>It also plays very nicely with the pipeline pattern above for creating pipelines in a fluent manner. Even if you just create extension methods which call a constructor to wrap/compose the previous stage in the pipeline, you can still end up with more readable code.</p>  <p>One <em>problem</em> with this is that you can&#39;t &quot;override&quot; behaviour in particular implementations or interfaces which extend the original one - which is why Enumerable.ElementAt() has to detect that a sequence is actually a list, for example. If interfaces allowed method implementations, this wouldn&#39;t be as much of a problem in the situation where you&#39;re in control of the interface - I wouldn&#39;t be at all surprised to find that as a feature of C#&#39;s successor.</p>  <p>The lack of extension properties is also a bit of a handicap in some places, although not as many as one might expect at first glance. For example, even if we <em>could</em> have made Enumerable.Count() a property, would it have been a good idea to do so? Properties give a natural expectation of speed, and Count() is usually an O(n) operation.</p>  <h3>Delegates for custom behaviour</h3>  <p>In .NET 1.0 and 1.1, most developers used delegates for two purposes:</p>  <ul>   <li>Handling events in UIs </li>    <li>Passing around behaviour to be executed in a different thread (either via Control.Invoke, or new Thread(ThreadStart), or ThreadPool.QueueUserWorkItem). </li> </ul>  <p>.NET 2.0 increased the range of uses of delegates somewhat, particularly with List.ConvertAll and the ability to create delegates relatively easily using anonymous methods.</p>  <p>However, LINQ <em>really</em> brought them into the mainstream. If you&#39;re building an API which benefits from <em>small</em> pieces of custom behaviour, delegates can be a real boon. More complicated behaviour is still often best represented via an interface, and <em>sometimes</em> it&#39;s worth having both interface and delegate representations, like Comparison&lt;T&gt; and IComparable&lt;T&gt;. It&#39;s generally easy to convert between the two - especially if you use a method group conversion from an interface implementation&#39;s method to the delegate type.</p>  <h3>Laziness</h3>  <p>One aspect of LINQ which is both a blessing and a curse is its laziness, both in terms of deferred execution (not reading from the input sequence <em>at all</em> until the result sequence is read) and in terms of streaming the data (only reading as much information from the input sequence as is required to answer the immediate needs of the caller).</p>  <p>This is great in various ways, particularly as it means you can build a complex query and use it multiple times, sometimes as a basis for other queries, knowing that it won&#39;t actually do anything until you ask for real results. It also means that you can iterate over huge data sets, so long as you&#39;re careful.</p>  <p>On the other hand, it leads to subtle issues over when code is actually executing, makes debugging harder to understand, makes it easier to accidentally change the values of captured variables between the point at which you create the query and the point at which you execute it, and basically messes with your head. This is probably the aspect of LINQ which confuses newbies more than any other.</p>  <p>I&#39;m not saying it was the wrong decision for LINQ - but I <em>would</em> caution API designers to think carefully before introducing laziness, and to document it <em>really</em> thoroughly. Likewise if your API might end up returning a result which is &quot;gradually evaluated&quot; (streaming data etc), this should be made clear.</p>  <h3>When names collide: options for consistency</h3>  <p>Just in case you&#39;ve forgotten, this is irritation with the meaning of source.Contains(element). In order to check whether a sequence contains an element or not, there has to be some idea of equality - for example, if you&#39;re trying to find one string in a sequence of strings, are you trying to match in a case sensitive manner or not?</p>  <p>There&#39;s an overload for Enumerable.Contains which allows you to specify the equality comparer to use, but the question is what should happen when you let the implementation pick the comparer.</p>  <p>For <em>every</em> other method in Enumerable, the default equality comparer for the sequence type - i.e. EqualityComparer&lt;TSource&gt;.Default - is picked. That sounds like source.Contains(element) should use the element type&#39;s default comparer too, right? Well, in some cases that&#39;s what will happen... but not if the source implements ICollection&lt;T&gt;, which has its own Contains method which doesn&#39;t take an equality comparer. If that&#39;s the case, LINQ to Objects delegates to the collection&#39;s Contains method.</p>  <p>So, we have three kinds of consistency here:</p>  <ul>   <li>Consistency of compile-time type: it would be nice if the behaviour of source.Contains(element) was the same whether &quot;source&quot; is of type IEnumerable&lt;T&gt; and ICollection&lt;T&gt; </li>    <li>Consistency of API: it would be nice if Contains behaved the same way as other methods which have overloads with and without equality comparers </li>    <li>Consistency of model: if you consider &quot;source&quot; to be just a sequence of elements, it shouldn&#39;t affect the <em>result</em> (not just the speed) if the object actually implements ICollection&lt;T&gt; </li> </ul>  <p>I should point out that this will <em>only</em> be a problem if the collection uses a different notion of equality to the default equality comparer for the type. The most obvious example of this is if you have a HashSet&lt;string&gt; which uses a case-insensitive equality comparer. But it&#39;s still a valid concern.</p>  <p>So what should the API designer do in this kind of case? Admittedly LINQ to Objects is already in a slightly unusual position as it&#39;s based on an existing interface with known and <em>very common</em> interfaces extending that core one... it&#39;s less likely to come up with other APIs. However, I think it <em>might</em> be enough of a smell to suggest that changing the name of the method to &quot;ContainsElement&quot; or something similar would be worthwhile. It&#39;s unfortunate that &quot;Contains&quot; really <em>is</em> the obvious choice...</p>  <p>This issue raises another aspect of API decision I&#39;ve considered in the past... if there&#39;s a common way of doing something in the framework you&#39;re building on top of, but you consider it to be broken, should you abide by that breakage for the sake of familiarity and consistency, or should you strive to be as &quot;clean&quot; as possible? I think it needs to be considered on a case-by-case basis, but I <em>suspect</em> I would usually come down on the side of cleanliness.</p>  <h3>Documentation details</h3>  <p>Almost all APIs are badly documented - it&#39;s a fact of life, even with some of the best APIs I&#39;ve worked with. I doubt that Noda Time will be a shining example either. However, at the risk of being hypocritical I&#39;ll say that documentation is worth spending significant thought on. Not just the time taken to document your code - but the time taken to consider what you want to guarantee, what should be left unstated, and what should be <em>explicitly</em> left open.</p>  <p>For example, there&#39;s no indication in the documentation of Cast that it will <em>sometimes</em> return the original source value, nor in its companion OfType method that that will <em>never </em>return the original source reference. This might be important to someone - why not state it? It&#39;s possible to state the <em>possibility</em> without saying what cases it applies to of course, leaving some wiggle room in the future. You might consider some of the optimizations in the same way - when should an optimization be documented and when should it be implicit? Sometimes it can make a difference beyond just performance, even if only in &quot;odd&quot; situations (such as a predicate throwing an exception).</p>  <p>If you&#39;re used to defensive coding with Code Contracts, it&#39;s much the same type of decision - and again, it&#39;s similar to deciding whether a method should return IEnumerable&lt;T&gt;, IList&lt;T&gt; or List&lt;T&gt;. There&#39;s a balance between caller convenience, design cleanliness (where you only want to <em>emphasize</em> one interface aspect, even if it also <em>happens</em> to always return a particular type), and room for the implementation to change in the future.</p>  <p>Another example of considering the level of detail to document is when it comes to how input sequences are used in LINQ to Objects. What does it mean to say &quot;this method uses deferred execution&quot; <em>exactly</em>? If I call GetEnumerator() eagerly but defer the call to MoveNext(), is that still &quot;deferred execution&quot;? Should the documentation state when a sequence is buffered and when it&#39;s streamed? Should it guarantee the order of the result sequence when the natural implementation makes that order easy to describe (e.g. for Distinct)? In this series I&#39;ve tried to be as clear as possible about what actually happens - but that&#39;s not to say that in some cases, the documentation wasn&#39;t left <em>deliberately</em> ambiguous.</p>  <h3>Conclusion</h3>  <p>There are many other design considerations that I haven&#39;t gone into here - particularly optimization, which I&#39;ve already covered twice, probably saying everything I wanted to say here anyway.</p>  <p>I may add a few more bits to this post over time... but aside from that, I think I&#39;m fundamentally <em>done</em>. I&#39;ll write one more conclusion post, then declare Edulinq closed...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
