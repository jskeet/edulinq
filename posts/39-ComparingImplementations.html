<html>
<head>
<title>Reimplementing LINQ to Objects: Part 39 - Comparing implementations</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 39 - Comparing implementations</h1>
<p>While implementing Edulinq, I only focused on two implementations: .NET 4.0 and Edulinq. However, I was aware that there were other implementations available, notably <a href="http://linqbridge.googlecode.com">LinqBridge</a> and the one which comes with <a href="http://mono-project.com">Mono</a>. Obviously it&#39;s interesting to see how other implementations behave, so I&#39;ve now made a few changes in order to make the test code run in these different environments.</p>  <h3>The test environments</h3>  <p>I&#39;m using Mono 2.8 (I can&#39;t remember the minor version number offhand) but I tend to think of it as &quot;Mono 3.5&quot; or &quot;Mono 4.0&quot; depending on which runtime I&#39;m using and which base libraries I&#39;m compiling against, to correspond with the .NET versions. Both runtimes ship as part of Mono 2.8. I will use these version numbers for this post, and ask forgiveness for my lack of precision: whenever you see &quot;Mono 3.5&quot; please just think &quot;Mono 2.8 running against the 2.0 runtime, possibly using some of the class libraries normally associated with .NET 3.5&quot;.</p>  <p>LinqBridge is a bit like Edulinq - a clean room implementation of LINQ to Objects, but built against .NET 2.0. It contains its own Func delegate declarations and its own version of ExtensionAttribute for extension methods. In my experience this makes it difficult to use with the &quot;real&quot; .NET 3.5, so my build targets .NET 2.0 when running against LinqBridge. This means that tests using HashSet had to be disabled. The version of LinqBridge I&#39;m running against is 1.2 - the latest binary available on the web site. This has AsEnumerable as a plain static method rather than an extension method; the code has been fixed in source control, but I wanted to run against a prebuilt binary, so I&#39;ve just disabled my own AsEnumerable tests for LinqBridge. Likewise the tests for Zip are disabled both for LinqBridge and the &quot;Mono 3.5&quot; tests as Zip was only introduced in .NET 4.</p>  <p>The other issue of not having .NET 4 available in the tests is that the string.Join&lt;T&gt;(string, IEnumerable&lt;T&gt;) overload is unavailable - something I&#39;d used quite a lot in the test code. I&#39;ve created a new static class called &quot;StringEx&quot; and replaced string.Join with StringEx.Join everywhere.</p>  <p>There are batch files under a new &quot;testing&quot; directory which will build and run:</p>  <ul>   <li>Microsoft&#39;s LINQ to Objects and Edulinq under .NET </li>    <li>LinqBridge, Mono 3.5&#39;s LINQ to Objects and Edulinq under Mono 3.5 </li>    <li>Mono 4.0&#39;s LINQ to Objects and Edulinq under Mono 4.0 </li> </ul>  <p>Although I have LinqBridge running under .NET 2.0 in Visual Studio, it&#39;s a bit of a pain building the tests from a batch file (at least without just calling msbuild). The failures running under Mono 3.5 are the same as those running under .NET 2.0 as far as I can tell, so I&#39;m not too worried.</p>  <p>Note that while I have built the Mono tests under both the 3.5 and 4.0 profiles, the results were the same other than due to generic variance, so I&#39;ve only included the results of the 4.0 profile below.</p>  <h3>What do the tests cover?</h3>  <p>Don&#39;t forget that the Edulinq tests were written in the spirit of investigation. They cover aspects of LINQ&#39;s behaviour which are not guaranteed, both in terms of optimization and simple correctness of behaviour. I have included a test which demonstrates the &quot;issue&quot; with calling Contains on an ICollection&lt;T&gt; which uses a non-default equality comparer, as well as the known issue with OrderByDescending using a comparer which returns int.MinValue. There are optimizations which are present in Edulinq but not in LINQ to Objects, and I have tests for those, too.</p>  <p>The tests which fail against Microsoft&#39;s implementation (for known reasons) are normally marked with an [Ignore] attribute to prevent them from alarming me unduly during development. NUnit categories would make more sense here, but I don&#39;t believe ReSharper supports them, and that&#39;s the way I run the tests normally. Likewise the tests which take a very long time (such as counting more than int.MaxValue elements) are normally suppressed.</p>  <p>In order to truly run <em>all</em> my tests, I now have a horrible hack using conditional compilation: if the ALL_TESTS preprocessor symbol is defined, I build my own IgnoreAttribute class in the Edulinq.Tests namespace, which effectively takes precedence over the NUnit one... so NUnit will ignore the [Ignore], so to speak. Frankly all this conditional compilation is pretty horrible, and I wouldn&#39;t use it for a &quot;real&quot; project, but this is a slightly unusual situation.</p>  <p>EDIT: It turns out that ReSharper <em>does</em> support categories. I&#39;m not sure how far that support goes yet, but at the very least there&#39;s &quot;Group by categories&quot; available. I may go through <em>all</em> my tests and apply a category to each one: optimization, execution mode, time-consuming etc. We&#39;ll see whether I can find the energy for that :)</p>  <p>So, let&#39;s have a look at what the test results are...</p>  <h3>Edulinq</h3>  <p>Unsurprisingly, Edulinq passes all its own tests, with the minor exception of CastTest.OriginalSourceReturnedDueToGenericCovariance running under Mono 3.5, which doesn&#39;t include covariance. Arguably this test should be conditionalised to not even run in that situation, as it&#39;s not expected to work.</p>  <h3>Microsoft&#39;s LINQ to Objects</h3>  <p>8 failures, all expected:</p>  <ul>   <li>Contains delegates to the ICollection&lt;T&gt;.Contains implementation if it exists, rather than using the default comparer for the type. This is a design and documentation issue which I&#39;ve discussed in more detail in the <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/12/reimplementing-linq-to-objects-part-32-contains.aspx">Contains part of this series</a>. </li>    <li>Optimization: ElementAt and ElementAtOrDefault don&#39;t validate the specified index eagerly when the input sequence implements ICollection&lt;T&gt; but not IList&lt;T&gt;. </li>    <li>Optimization: OfType always uses an intermediate iterator even when the input sequence already implements IEnumerable&lt;T&gt; and T is a non-nullable value type. </li>    <li>Optimization: SequenceEqual doesn&#39;t compare the counts of the sequences eagerly even when both sequences implement ICollection&lt;T&gt; </li>    <li>Correctness: OrderByDescending doesn&#39;t work if you use a key comparer which returns int.MinValue</li>    <li>Consistency: Single and SingleOrDefault (with a predicate) don&#39;t throw InvalidOperationException as soon as they encounter a second element matching the predicate; the predicate-less overloads <em>do</em> throw as soon as they see a second element.</li> </ul>  <p>All of these have been discussed already, so I won&#39;t go into them now.</p>  <h3>LinqBridge</h3>  <p>LinqBridge had a total of 33 failures. I haven&#39;t looked into them in detail, but just going from the test output I&#39;ve broken them down into the following broad categories:</p>  <ul>   <li>Optimization:      <ul>       <li>Cast never returns the original source, presumably always introducing an intermediate iterator. </li>        <li>All three of Microsoft&#39;s &quot;missed opportunities&quot; listed above are also missed in LinqBridge </li>     </ul>   </li>    <li>Use of input sequences:      <ul>       <li>Except and Intersect appear to read the first sequence first (possibly completely?) and then the second sequence. Edulinq and LINQ to Objects read the second sequence completely and then stream the first sequence. This behaviour is undocumented. </li>        <li>Join, GroupBy and GroupJoin appear not to be deferred at all. If I&#39;m right, this is a definite bug. </li>        <li>Aggregation accuracy: both Average and Sum over an IEnumerable&lt;float&gt; appear to use a float accumulator instead of a double. This is probably worth fixing for the sake of both range and accuracy, but isn&#39;t specified in the documentation. </li>        <li>OrderBy (etc) appears to apply the key selector multiple times while sorting. The behaviour here isn&#39;t documented, but as I <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/05/reimplementing-linq-to-objects-part-26b-orderby-descending-thenby-descending.aspx">mentioned before</a>, it could produce performance issues unnecessarily. </li>     </ul>   </li>    <li>Exceptions:      <ul>       <li>ToDictionary should throw an exception if you give it duplicate keys; it appears not to - at least when a custom comparer is used. (It&#39;s possible it&#39;s just not passing the comparer along.) </li>        <li>The generic Max and Min methods don&#39;t return the null value for the element type when that type is nullable. Instead, they throw an exception - which is the normal behaviour if the element type is non-nullable. This behaviour isn&#39;t well documented, but is consistent with the behaviour of the non-generic overloads. See the <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/09/reimplementing-linq-to-objects-part-29-min-max.aspx">Min/Max post</a> for more details. </li>     </ul>   </li>    <li>General bugs:      <ul>       <li>The generic form of Min/Max appears not to ignore null values when the element type is nullable. </li>        <li>OrderByDescending appears to be broken in the same way as Microsoft&#39;s implementation </li>        <li>Range appears to be broken around its boundary testing.</li>        <li>Join, GroupJoin, GroupBy and ToLookup break when presented with null keys</li>     </ul>   </li> </ul>  <h3>Mono 4.0 (and 3.5, effectively)</h3>  <p>Mono failed 18 of the tests. There are fewer definite bugs than in LinqBridge, but it&#39;s definitely not perfect. Here&#39;s the breakdown:</p>  <ul>   <li>Optimization:      <ul>       <li>Mono misses the same three opportunities that LinqBridge and Microsoft miss. </li>        <li>Contains(item) delegates to ICollection&lt;T&gt; when it&#39;s implemented, just like in the Microsoft implementation. (I assume the authors would call this an &quot;optimization&quot;, hence its location in this section.) I believe that LinqBridge has the same behaviour, but that test didn&#39;t run in the LinqBridge configuration as it uses HashSet. </li>     </ul>   </li>    <li>Average/Sum accumulator types:      <ul>       <li>Mono appears to use float when working with float values, leading to more accumulator error than is necessary. </li>     </ul>   </li>    <li>Average overflow for integer types      <ul>       <li>Mono appears to use checked arithmetic when <em>summing</em> a sequence, but not when taking the <em>average</em> of a sequence. So the average of { long.MaxValue, long.MaxValue, 2 } is 0. (This originally confused me into thinking it was using floating point types during the summation, but I now believe it&#39;s just a checked/unchecked issue.) </li>     </ul>   </li>    <li>Bugs:      <ul>       <li>Count doesn&#39;t overflow either with or without a predicate </li>        <li>The Max handling of double.NaN isn&#39;t in line with .NET. I haven&#39;t investigated the reason for this yet. </li>        <li>OrderByDescending is broken in the same way as for LinqBridge and the Microsoft implementation. </li>        <li>Range is broken for both Range(int.MinValue, 0) and Range(int.MaxValue, 1). Test those boundary cases, folks :) </li>        <li>When reversing a list, Mono <em>doesn&#39;t</em> buffer the current contents. In other words, changes made while iterating over the reversed list are visible in the returned sequence. The documentation isn&#39;t very clear about the desired behaviour here, admittedly.</li>        <li>GroupJoin and Join match null keys, unlike Microsoft&#39;s implementation.</li>     </ul>   </li> </ul>  <h3>How does Edulinq fare against other unit tests?</h3>  <p>It didn&#39;t seem fair to <em>only</em> test other implementations against the Edulinq tests. After all, it&#39;s only natural that my tests should work against my own code. What happens if we run the Mono and LinqBridge tests against my code?</p>  <p>The LinqBridge tests didn&#39;t find anything surprising. There were two failures:</p>  <ul>   <li>I don&#39;t have the &quot;delegate Contains to ICollection&lt;T&gt;.Contains&quot; behaviour, which the tests check for. </li>    <li>I don&#39;t optimize First in the case of the collection implementing IList&lt;T&gt;. I view this as a pretty dubious optimization to be honest - I doubt that creating an iterator to get to the first item is going to be much slower than checking for IList&lt;T&gt;, fetching the count, and then fetching the first item via the indexer... and it means that all <em>non-list</em> implementations also have to check whether the sequence implements IList&lt;T&gt;. I don&#39;t intend to change Edulinq for this. </li> </ul>  <p>The Mono tests picked up the same two failures as above, and two <em>genuine</em> bugs:</p>  <ul>   <li>By implementing Take via TakeWhile, I was iterating too far: in order for the condition to become false, we had to iterate to the first item we <em>wouldn&#39;t</em> return. </li>    <li>ToLookup didn&#39;t accept null keys - a fault which propagated to GroupJoin, Join and GroupBy too. (EDIT: It turns out that it&#39;s more subtle than that. Nothing should break, but the MS implementation <em>ignores</em> null keys for Join and GroupJoin. Edulinq now does the same, but I&#39;ve raised a <a href="https://connect.microsoft.com/VisualStudio/feedback/details/639943/enumerable-join-groupjoin-ignores-null-keys-inconsistency-with-tolookup-and-groupby">Connect issue</a> to suggest this should <em>at least</em> be documented.)</li> </ul>  <p>I&#39;ve fixed these in source control, and will add an addendum to each of the relevant posts (<a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/02/reimplementing-linq-to-objects-part-23-take-skip-takewhile-skipwhile.aspx">Take</a>, <a href="http://msmvps.com/blogs/jon_skeet/archive/2010/12/31/reimplementing-linq-to-objects-part-18-tolookup.aspx">ToLookup</a>) when I have a moment spare.</p>  <p>There&#39;s one additional failure, trying to find the average of a sequence of two Int64.MaxValue values. That overflows on both Edulinq and LINQ to Objects - that&#39;s the downside of using an Int64 to sum the values. As mentioned, Mono suffers a degree of inaccuracy instead; it&#39;s all a matter of trade-offs. (A <em>really</em> smart implementation might use Int64 while possible, and then go up to using Double where necessary, I suppose.)</p>  <p>Unfortunately I don&#39;t have the tests for the<em> </em>Microsoft implementation, of course... I&#39;d love to know whether there&#39;s anything I&#39;ve failed with there.</p>  <h3>Conclusion</h3>  <p>This was very interesting - there&#39;s a mixture of failure conditions around, and plenty of &quot;non-failures&quot; where each implementation&#39;s tests are enforcing their own behaviour.</p>  <p>I do find it amusing that all three of the &quot;mainstream&quot; implementations have the same OrderByDescending bug though. Other than that, the clear bugs between Mono and LinqBridge don&#39;t intersect, which is slightly surprising.</p>  <p>It&#39;s nice to see that despite not setting out to create a &quot;production-quality&quot; implementation of LINQ to Objects, that&#39;s <em>mostly</em> what I&#39;ve ended up with. Who knows - maybe some aspects of my implementation or tests will end up in Mono in the future :)</p>  <p>Given the various different optimizations mentioned in this post, I think it&#39;s only fitting that next time I&#39;ll discuss where we <em>can</em> optimize, where it&#39;s <em>worth</em> optimizing, and some more tricks we could still pull out of the bag...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
