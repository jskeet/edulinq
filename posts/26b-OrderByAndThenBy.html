<html>
<head>
<title>Reimplementing LINQ to Objects: Part 26b - OrderBy{,Descending}/ThenBy{,Descending}</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 26b - OrderBy{,Descending}/ThenBy{,Descending}</h1>
<p>Last time we looked at IOrderedEnumerable&lt;TElement&gt; and I gave an implementation we could use in order to implement the public extension methods within LINQ. I&#39;m still going to do that in this post, but it&#39;s worth mentioning something else that&#39;s coming up in another part (26d) - I&#39;m going to revisit my OrderedEnumerable implementation.</p>  <h3>There may be trouble ahead...</h3>  <p>A comment on the previous post mentioned how my comparer executes the keySelector on each element every time it makes a comparison. I didn&#39;t think of that as a particularly awful problem, until I thought of this sample query to rank people&#39;s favourite colours:</p>  <div class="code"><span class="Linq">var</span> query = people.GroupBy(p =&gt; p.FavouriteColour)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .OrderByDescending(g =&gt; g.Count())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(g =&gt; g.Key); </div>  <p>Eek. Now every time we compare two elements, we have to count everything in a group. Ironically, I believe that counting the items in a group is fast using the LINQ to Objects implementation, but not in mine - something I may fix later on. But with LINQ to Objects, this wouldn&#39;t cause a problem in the first place!</p>  <p>There are ways to make this use an efficient key selector, of course - a simple Select before the OrderByDescending call would do fine... but it would be nicer if it wasn&#39;t a problem in the first place. Basically we want to extract the keys for each element <em>once</em>, and then compare them repeatedly when we need to. This would also allow us to shuffle a sequence using code such as this:</p>  <div class="code">Random rng = <span class="Keyword">new</span> Random(); <span class="InlineComment">// Or get it from elsewhere...</span>     <br /><span class="Linq">var</span> shuffled = collection.OrderBy(x =&gt; rng.NextDouble()); </div>  <p>I&#39;m not advocating that way of shuffling, admittedly - but it would be nice if it didn&#39;t cause significant problems, which it currently would, as the key selector is non-deterministic.</p>  <p>The interesting thing is that when I&#39;ve finished today&#39;s post, I believe the code will obey all the <em>documented</em> behaviour of LINQ to Objects: there&#39;s nothing in the documentation about how often the key selector will be called. That doesn&#39;t mean it&#39;s a good idea to ignore this problem though, which is why I&#39;ll revisit OrderedEnumerable later. However, that&#39;s going to complicate the code somewhat... so while we&#39;re still getting to grips with how everything hangs together, I&#39;m going to stick to my inefficient implementation.</p>  <p>Meanwhile, back to the actual LINQ operators for the day...</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.orderby.aspx">OrderBy</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.orderbydescending.aspx">OrderByDescending</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.thenby.aspx">ThenBy</a> and <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.thenbydescending.aspx">ThenByDescending</a> all have very similar overloads:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IOrderedEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IOrderedEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IOrderedEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IOrderedEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer) </div>  <p>They&#39;re all extension methods, but ThenBy/ThenByDescending are extension methods on IOrderedEnumerable&lt;T&gt; instead of IEnumerable&lt;T&gt;.</p>  <p>We&#39;ve already talked about what they do to some extent - each of them returns a sequence which is ordered according to the specified key. However, in terms of details:</p>  <ul>   <li>The source and keySelector parameters can&#39;t be null, and are validated eagerly. </li>    <li>The comparer parameter (where provided) can be null, in which case the default comparer for the key type is used. </li>    <li>They use deferred execution - the input sequence isn&#39;t read until it has to be. </li>    <li>They read and buffer the entire input sequence when the result is iterated. Or rather, they buffer the <em>original</em> input sequence - as I mentioned last time, when a compound ordered sequence (source.OrderBy(...).ThenBy(...).ThenBy(...)) is evaluated, the final query will go straight to the source used for OrderBy, rather than sorting separately for each key. </li> </ul>  <h3>What are we going to test?</h3>  <p>I have tests for the following:</p>  <ul>   <li>Deferred execution (using ThrowingEnumerable) </li>    <li>Argument validation </li>    <li>Ordering stability </li>    <li>Simple comparisons </li>    <li>Custom comparers </li>    <li>Null comparers </li>    <li>Ordering of null keys </li> </ul>  <p>In all of the tests which don&#39;t go bang, I&#39;m using an anonymous type as the source, with integer &quot;Value&quot; and &quot;Key&quot; properties. I&#39;m ordering using the key, and then selecting the value - like this:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> OrderingIsStable()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> source = <span class="Keyword">new</span>[]     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { Value = 1, Key = 10 },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { Value = 2, Key = 11 },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { Value = 3, Key = 11 },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { Value = 4, Key = 10 },     <br />&#160;&#160;&#160; };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = source.OrderBy(x =&gt; x.Key)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(x =&gt; x.Value);     <br />&#160;&#160;&#160; query.AssertSequenceEqual(1, 4, 2, 3);     <br />} </div>  <p>For ThenBy/ThenByDescending I have multiple key properties so I can test the interaction between the primary and secondary orderings. For custom key comparer tests, I have an AbsoluteValueComparer which simply compares the absolute values of the integers provided.</p>  <p>The &quot;Value&quot; property is always presented in ascending order (from 1) to make it easier to keep track of, and the &quot;Key&quot; properties are always significantly larger so we can&#39;t get confused between the two. I originally used strings for the keys in all tests, but then I found out that the default string comparer was culture-sensitive and didn&#39;t behave how I expected it to. (The default string <em>equality</em> comparer uses ordinal comparisons, which are rather less brittle...) I still use strings for the keys in nullity tests, but there I&#39;m specifying the ordinal comparer.</p>  <p>I wouldn&#39;t claim the tests are exhaustive - by the time you&#39;ve considered multiple orderings with possibly equal keys, different comparers etc the possibilities are overwhelming. I&#39;m reasonably confident though (particularly after the tests found some embarrassing bugs in the implementation). I don&#39;t think they&#39;re <em>hugely</em> readable either - but I was very keen to keep the value separated from the key, rather than just ordering by &quot;x =&gt; x&quot; in tests. If anyone fancies cloning the repository and writing better tests, I&#39;d be happy to merge them :)</p>  <p>What I deliberately <em>don&#39;t</em> have yet is a test for how many times the key selector is executed: I&#39;ll add one before post 26d, so I can prove we&#39;re doing the right thing eventually.</p>  <h3>Let&#39;s implement them!</h3>  <p>We&#39;ve got two bits of implementation to do before we can run the tests:</p>  <ul>   <li>The extension methods </li>    <li>The GetEnumerator() method of OrderedEnumerable </li> </ul>  <p>The extension methods are extremely easy. All of the overloads without comparers simply delegate to the ones with comparers (using Comparer&lt;TKey&gt;.Default) and the remaining methods look like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> OrderedEnumerable&lt;TSource&gt;(source,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> ProjectionComparer&lt;TSource, TKey&gt;(keySelector, comparer));     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; IComparer&lt;TSource&gt; sourceComparer = <span class="Keyword">new</span> ProjectionComparer&lt;TSource, TKey&gt;(keySelector, comparer);     <br />&#160;&#160;&#160; sourceComparer = <span class="Keyword">new</span> ReverseComparer&lt;TSource&gt;(sourceComparer);     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> OrderedEnumerable&lt;TSource&gt;(source, sourceComparer);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IOrderedEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.CreateOrderedEnumerable(keySelector, comparer, <span class="Keyword">false</span>);     <br />} </div>  <p>(To get ThenByDescending, just change the name of the method and change the last argument of CreateOrderedEnumerable to true.)</p>  <p>All very easy. I&#39;m pretty sure I&#39;m going to want to change the OrderedEnumerable constructor to accept the key selector and key comparer in the future (in 26d), which will make the above code even simpler. That can wait a bit though.</p>  <p>Now for the sorting part in OrderedEnumerable. Remember that we need a <em>stable</em> sort, so we can&#39;t just delegate to List&lt;T&gt;.Sort - at least, not without a bit of extra fiddling. (We could project to a type which contained the index, and add that onto the end of the comparer as a final tie-breaker.)</p>  <p>For the minute - and I swear it won&#39;t stay like this - here&#39;s the horribly inefficient (but easy to understand) implementation I&#39;ve got:</p>  <div class="code"><span class="Modifier">public</span> IEnumerator&lt;TElement&gt; GetEnumerator()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// This is a truly sucky way of implementing it. It&#39;s the simplest I could think of to start with.</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// We&#39;ll come back to it!</span>     <br />&#160;&#160;&#160; List&lt;TElement&gt; elements = source.ToList();     <br />&#160;&#160;&#160; <span class="Statement">while</span> (elements.Count &gt; 0)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TElement minElement = elements[0];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> minIndex = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 1; i &lt; elements.Count; i++)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (currentComparer.Compare(elements[i], minElement) &lt; 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; minElement = elements[i];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; minIndex = i;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; elements.RemoveAt(minIndex);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> minElement;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>We simply copy the input to a list (which is something we may well do in the final implementation - we certainly need to suck it all in somehow) and then repeatedly find the minimum element (favouring earlier elements over later ones, in order to achieve stability), removing them as we go. It&#39;s an O(n<sup>2</sup>) approach, but hey - we&#39;re going for correctness first.</p>  <h3>Conclusion</h3>  <p>This morning, I was pretty confident this would be an easy and quick post to write. Since then, I&#39;ve been found pain in the following items:</p>  <ul>   <li>Calling key selectors only once per element is more important than it might sound at first blush </li>    <li>The default sort order for string isn&#39;t what I&#39;d have guessed </li>    <li>My (committed!) extension methods were broken, because I hadn&#39;t edited them properly after a cut and paste </li>    <li>Writing tests for situations where there are lots of combinations is irritating </li> </ul>  <p>So far these have only extended my estimated number of posts for this group of operators to 4 (26a-26d) but who knows what the next few days will bring...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
