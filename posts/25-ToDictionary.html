<html>
<head>
<title>Reimplementing LINQ to Objects: Part 25 - ToDictionary</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 25 - ToDictionary</h1>
<p>This one ended up being <em>genuinely</em> easy to implement, although with lots of tests for different situations.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.todictionary.aspx">ToDictionary</a> has four overloads which look remarkably similar to the ones we used for ToLookup:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> Dictionary&lt;TKey, TSource&gt; ToDictionary&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> Dictionary&lt;TKey, TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> Dictionary&lt;TKey, TSource&gt; ToDictionary&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> Dictionary&lt;TKey, TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer) </div>  <p>Yes, it&#39;s the ever-popular combination of an optional key comparer and an optional element selector when mapping values.</p>  <p>ToDictionary does exactly what it says on the tin: it converts the source sequence to a dictionary. Each source item is mapped to a key, and then either the source item itself is used as the value or the element selector is applied to obtain one. A custom equality comparer can be used to create a dictionary which is (for example) case-insensitive when fetching keys.</p>  <p>The main difference between ToDictionary and ToLookup is that a dictionary can only store a single value per key, rather than a whole sequence of values. Of course, another difference is that Dictionary&lt;TKey, TValue&gt; is mutable concrete class, whereas ILookup&lt;TKey, TElement&gt; is an interface usually implemented in an immutable fashion.</p>  <p>The normal sort of note:</p>  <ul>   <li>ToDictionary uses <em>immediate execution</em>: it reads the entire source sequence, and once it has returned, the dictionary is independent of the source </li>    <li>source, keySelector and elementSelector mustn&#39;t be null </li>    <li>comparer <em>can</em> be null, in which case the default equality comparer for the key type will be used </li>    <li>No key can appear more than once (including non-identical but equal occurrences). This will cause an ArgumentException </li>    <li>Null keys are prohibited, causing an ArgumentNullException. (This is slightly odd, as the ToDictionary method itself <em>doesn&#39;t</em> have a null argument at this point... really it should be a NullValueDerivedFromAnArgumentSomehowException, but that doesn&#39;t exist) </li>    <li>Null values are allowed </li> </ul>  <p>Just a word on usage: one place I&#39;ve seen ToDictionary used to reasonable effect is when the source is an IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, often from another dictionary. This lets you project all the values of a dictionary, or perhaps &quot;trim&quot; the dictionary in some ways... creating a new dictionary rather than modifying the existing one, of course. For example, here&#39;s a way of creating a new Dictionary&lt;string, Person&gt; from an existing one, but only keeping the entries which are adults:</p>  <div class="code"><span class="Linq">var</span> adults = nameToPersonMap.Where(pair =&gt; pair.Value.Age &gt;= 18)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value); </div>  <p>Of course, this is just one use - it can be a pretty handy operator, to be frank.</p>  <h3>What are we going to test?</h3>  <p>Just the &quot;null argument&quot; validation tests gives us ten tests to start with, then:</p>  <ul>   <li>A test for each overload, always mapping a sequence of strings to a map using the first letter as the key; sometimes as a char and sometimes as a string (so we can easily use a case-insensitive comparer) </li>    <li>A test for null keys (ArgumentNullException) </li>    <li>A test for null values (no exception) </li>    <li>A test for duplicate keys (ArgumentException) </li>    <li>A test for a null comparer (uses the default) </li> </ul>  <h3>Let&#39;s implement it!</h3>  <p>In my implementation, the first three overloads all call the last - just using a default equality comparer or an identity element selector where necessary. Then after the argument validation, the implementation is simple:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> Dictionary&lt;TKey, TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; Dictionary&lt;TKey, TElement&gt; ret = <span class="Keyword">new</span> Dictionary&lt;TKey, TElement&gt;(comparer ?? EqualityComparer&lt;TKey&gt;.Default);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret.Add(keySelector(item), elementSelector(item));     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>There&#39;s just one thing to be careful of - we have to use the <a href="http://msdn.microsoft.com/en-us/library/k7z0zy8k.aspx">Add method</a> instead of the <a href="http://msdn.microsoft.com/en-us/library/9tee9ht2.aspx">indexer</a> to add entries to the dictionary. The Add method deals with duplicate and null keys in exactly the way we want, whereas the indexer would overwrite the existing entry if we had a duplicate key.</p>  <p>There&#39;s one thing my implementation <em>doesn&#39;t</em> do which it could if we really wanted - it doesn&#39;t optimize the case where we know the size beforehand, because the source implements ICollection&lt;T&gt;. We could use the Dictionary constructor which takes a capacity in that case, like this:</p>  <div class="code">comparer = comparer ?? EqualityComparer&lt;TKey&gt;.Default;    <br />ICollection&lt;TSource&gt; list = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;     <br /><span class="Linq">var</span> ret = list == <span class="Keyword">null</span> ? <span class="Keyword">new</span> Dictionary&lt;TKey, TElement&gt;(comparer)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; : <span class="Keyword">new</span> Dictionary&lt;TKey, TElement&gt;(list.Count, comparer); </div>  <p>After all, we know the eventual size of the dictionary will be <em>exactly</em> the count of the input sequence, in the success case.</p>  <p>Is this worth it? I&#39;m not sure. It&#39;s not a huge change, admittedly... I&#39;m quite tempted to put it in. Again, we&#39;d have to benchmark it to see what difference it made (and I&#39;d benchmark the .NET implementation too, of course) but a unit test won&#39;t show it up. Thoughts welcome.</p>  <p>EDIT: I&#39;ve now edited the code to include this optimization. I haven&#39;t benchmarked it though...</p>  <h3>Conclusion</h3>  <p>Gah - even when I thought I had this wrapped up before starting to write the post, that final bit of potential optimization <em>still</em> appeared out of nowhere.</p>  <p>Idle thought: if we all had to write up our code in blog posts as we went along, we might discover some interesting alternative designs and implementations.</p>  <p>That&#39;s it for tonight, and I may not have any time for posts tomorrow - we&#39;ll see.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
