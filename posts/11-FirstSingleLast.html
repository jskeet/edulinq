<html>
<head>
<title>Reimplementing LINQ to Objects: Part 11 - First/Single/Last and the ...OrDefault versions</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 11 - First/Single/Last and the ...OrDefault versions</h1>
<p>Today I&#39;ve implemented six operators, each with two overloads. At first I expected the implementations to be very similar, but they&#39;ve all turned out slightly differently...</p>  <h3>What are they?</h3>  <p>We&#39;ve got three axes of permutation here: {First, Last, Single}, {with/without OrDefault }, {with/without a predicate}. That gives us these twelve signatures:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource First&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource First&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Last&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Last&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource LastOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource LastOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Single&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Single&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource SingleOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource SingleOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate) </div>  <p>The shared behaviour is as follows:</p>  <ul>   <li>They&#39;re all extension methods with a single generic type argument </li>    <li>They&#39;re all implemented with <em>immediate execution</em> </li>    <li>They all validate that their parameters are non-null </li>    <li>The overloads with a predicate are equivalent to calling source.Where(predicate).SameOperator() - in other words, they just add a filter before applying the operator. </li> </ul>  <p>With those rules applied, we simply need to consider three possibilities for each operator: what happens if the source sequence is empty, contains a single element, or contains multiple elements. (This is after applying the filter if a predicate is specified, of course.) We can draw the results up in a simple table:</p>  <table border="1" cellspacing="2" cellpadding="2"><tbody>     <tr>       <td><strong>Operator</strong></td>        <td>Empty sequence</td>        <td>Single element</td>        <td>Multiple elements</td>     </tr>      <tr>       <td>First</td>        <td>Throws exception</td>        <td>Returns element</td>        <td>Returns first element</td>     </tr>      <tr>       <td>FirstOrDefault</td>        <td>Returns default(TSource)</td>        <td>Returns element</td>        <td>Returns first element</td>     </tr>      <tr>       <td>Last</td>        <td>Throws exception</td>        <td>Returns element</td>        <td>Returns last element</td>     </tr>      <tr>       <td>LastOrDefault</td>        <td>Returns default(TSource)</td>        <td>Returns element</td>        <td>Returns last element</td>     </tr>      <tr>       <td>Single</td>        <td>Throws exception</td>        <td>Returns element</td>        <td>Throws exception</td>     </tr>      <tr>       <td>SingleOrDefault</td>        <td>Returns default(TSource)</td>        <td>Returns element</td>        <td>Throws exception</td>     </tr>   </tbody></table>  <p>As you can see, for an input sequence with a single element, the results are remarkably uniform :) Likewise, for an empty input sequence, any operator without &quot;OrDefault&quot; throws an exception (InvalidOperationException, in fact) and any operator with &quot;OrDefault&quot; returns the default value for the element type (null for reference types, 0 for int etc). The operators really differ if the (potentially filtered) input sequence contains multiple elements - First and Last do the obvious thing, and Single throws an exception. It&#39;s worth noting that SingleOrDefault <em>also</em> throws an exception - it&#39;s not like it&#39;s saying, &quot;If the sequence is a single element, return it - otherwise return the default value.&quot; If you <em>want</em> an operator which handles multiple elements, you should be using First or Last, with the &quot;OrDefault&quot; version if the sequence can legitimately have no elements. Note that if you <em>do</em> use an &quot;OrDefault&quot; operator, the result is exactly the same for an empty input sequence as for an input sequence containing exactly one element which is the default value. (I&#39;ll be looking at the DefaultIfEmpty operator next.)</p>  <p>Now we know what the operators do, let&#39;s test them.</p>  <h3>What are we going to test?</h3>  <p>This morning I tweeted that I had written 72 tests before writing any implementation. In fact I ended up with 80, for reasons we&#39;ll come to in a minute. For each operator, I tested the following 12 cases:</p>  <ul>   <li>Null source (predicate-less overload) </li>    <li>Null source (predicated overload) </li>    <li>Null predicate </li>    <li>Empty sequence, no predicate </li>    <li>Empty sequence, with a predicate </li>    <li>Single element sequence, no predicate </li>    <li>Single element sequence where the element matched the predicate </li>    <li>Single element sequence where the element didn&#39;t match the predicate </li>    <li>Multiple element sequence, no predicate </li>    <li>Multiple element </li>    <li>Multiple element sequence where one element matched the predicate </li>    <li>Multiple element sequence where multiple elements matched the predicate </li> </ul>  <p>These were pretty much cut and paste jobs - I used the same data for each test against each operator, and just changed the expected results.</p>  <p>There are two extra tests for each of First and FirstOrDefault, and two for each of Last and LastOrDefault:</p>  <ul>   <li>First/FirstOrDefault should return as soon as they&#39;ve seen the first element, when there&#39;s no predicate; they shouldn&#39;t iterate over the rest of the sequence </li>    <li>First/FirstOrDefault should return as soon as they&#39;ve seen the first <em>matching</em> element, when there is a predicate </li>    <li>Last/LastOrDefault are optimized for the case where the source implements IList&lt;T&gt; and there&#39;s no predicate: it uses Count and the indexer to access the final element </li>    <li>Last/LastOrDefault is <em>not</em> optimized for the case where the source implements IList&lt;T&gt; but there is a predicate: it iterates through the entire sequence </li> </ul>  <p>The last two tests involved writing a new collection called NonEnumerableList which implements IList&lt;T&gt; by delegating everything to a backing List&lt;T&gt;, except for GetEnumerator() (both the generic and nongeneric forms) which simply throws a NotSupportedException. That should be a handy one for testing optimizations in the future. I&#39;ll discuss the optimization for Last when we get there.</p>  <h3>Let&#39;s implement them!</h3>  <p>These operators were more interesting to implement than I&#39;d expect, so I&#39;m actually going to show all twelve methods. It was rarely just a matter of cutting and pasting, other than for the argument validation.</p>  <p>Of course, if we chose to implement the predicated versions using &quot;Where&quot; and the non-predicated form, and the &quot;OrDefault&quot; versions by using &quot;DefaultIfEmpty&quot; followed by the non-defaulting version, we would only have had the three non-predicated, non-defaulting versions to deal with... but as I&#39;ve said before, there are some virtues to implementing each operator separately.</p>  <p>For the sake of avoiding fluff, I&#39;ve removed the argument validation from each method - but obviously it&#39;s there in the real code. Let&#39;s start with First:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource First&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource First&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;No items matched the predicate&quot;</span>);     <br />} </div>  <p>These look surprisingly different - and that was actually a deliberate decision. I could easily have implemented the predicate-less version with a foreach loop as well, just returning unconditionally from its body. However, I chose to emphasize the fact that we&#39;re <em>not</em> looping in First: we simply move to the first element if we can, and return it or throw an exception. There&#39;s no <em>hint</em> that we might ever call MoveNext again. In the predicated form, of course, we have to keep looping until we find a matching value - only throwing the exception when we&#39;ve exhausted all possibilities.</p>  <p>Now let&#39;s see how it looks when we return a default for empty sequences:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> iterator.MoveNext() ? iterator.Current : <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Modifier">default</span>(TSource);     <br />} </div>  <p>Here the predicated form looks very similar to First, but the predicate-less one is slightly different: instead of using an if block (which would be a perfectly valid approach, of course) I&#39;ve used the conditional operator. We&#39;re <em>going</em> to return something, whether we manage to move to the first element or not. Arguably it would be nice if the conditional operator allowed the second or third operands to be &quot;throw&quot; expressions, taking the overall type of the expression from the other result operand... but it&#39;s no great hardship.</p>  <p>Next up we&#39;ll implement Single, which is actually closer to First than Last is, in some ways:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Single&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource ret = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence contained multiple elements&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Single&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; TSource ret = <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; <span class="ValueType">bool</span> foundAny = <span class="Keyword">false</span>;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (foundAny)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence contained multiple matching elements&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; foundAny = <span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (!foundAny)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;No items matched the predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>This is already significantly more complex than First. The predicate-less version starts off the same way, but if we manage to move to the first element, we have to remember that value (as we&#39;re <em>hoping</em> to return it) and then try to move to the <em>second</em> element. This time, if the move succeeds, we have to throw an exception - otherwise we can return our saved value.</p>  <p>The predicated version is even hairier. We still need to remember the first matching value we find, but this time we&#39;re looping - so we need to keep track of whether we&#39;ve already seen a matching value or not. If we see a second match, we have to throw an exception... and we <em>also</em> have to throw an exception if we reach the end without finding any matches at all. Note that although we assign an initial value of default(TSource) to ret, we&#39;ll never reach a return statement without assigning a value to it. However, the rules around definite assignment aren&#39;t smart enough to cope with this, so we need to provide a &quot;dummy&quot; value to start with... and default(TSource) is really the only value available. There is an alternative approach without using a foreach statement, where you loop until you find the first match, assign it to a local variable which is only declared at that point, followed by a second loop ensuring that there aren&#39;t any other matches. I personally think that&#39;s a bit more complex, which is why I&#39;ve just used the foreach here.</p>  <p>The difference when we implement SingleOrDefault isn&#39;t quite as pronounced this time though:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource SingleOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource ret = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence contained multiple elements&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource SingleOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; TSource ret = <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; <span class="ValueType">bool</span> foundAny = <span class="Keyword">false</span>;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (foundAny)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence contained multiple matching elements&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; foundAny = <span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>This time we&#39;ve just replaced a &quot;throw&quot; statement in the predicate-less method with a &quot;return&quot; statement, and removed the test for no matches being found in the predicated method. Here our assignment of default(TSource) to ret really works in our favour - if we don&#39;t end up assigning anything else to it, we&#39;ve already got the right return value!</p>  <p>Next up is Last:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Last&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; IList&lt;TSource&gt; list = source <span class="Keyword">as</span> IList&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (list != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (list.Count == 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> list[list.Count - 1];     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource last = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; last = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> last;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Last&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; <span class="ValueType">bool</span> foundAny = <span class="Keyword">false</span>;     <br />&#160;&#160;&#160; TSource last = <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; foundAny = <span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; last = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (!foundAny)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;No items matched the predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> last;     <br />} </div>  <p>Let&#39;s start off with the optimization at the beginning of the predicate-less method. If we find out we&#39;re dealing with a list, we can simply fetch the count, and then either throw an exception or return the element at the final index. As an extra bit of optimization I <em>could</em> store the count in a local variable - but I&#39;m assuming that the count of an IList&lt;T&gt; is cheap to compute. If there are significant objections to that assumption, I&#39;m happy to change it :) Note that this is another situation where I&#39;m assuming that anything implementing IList&lt;T&gt; will only hold at most Int32.MaxValue items - otherwise the optimization will fail.</p>  <p>If we <em>don&#39;t</em> follow the optimized path, we simply iterate over the sequence, updating a local variable with the last-known element on every single iteration. This time I&#39;ve avoided the foreach loop for no particularly good reason - we could easily have had a foundAny variable which was just set to &quot;true&quot; on every iteration, and then tested at the end. In fact, that&#39;s exactly the pattern the predicated method takes. Admittedly that decision is forced upon us to some extent - we can&#39;t just move once and then take the first value as the &quot;first last-known element&quot;, because it might not match the predicate.</p>  <p>There&#39;s no optimization for the predicated form of Last. This follows LINQ to Objects, but I don&#39;t honestly know the reason for it there. We could easily iterate backwards from the end of the sequence using the indexer on each iteration. One possible reason which makes a certain amount of sense is that when there&#39;s a predicate, that predicate could throw an exception for some values - and if we just skipped to the end if the collection implements IList&lt;T&gt;, that would be an observable difference. I&#39;d be interested to know whether or not that <em>is</em> the reason - if anyone has any inside information which they can share, I&#39;ll update this post.</p>  <p>From here, we only have one more operator to implement - LastOrDefault:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource LastOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; IList&lt;TSource&gt; list = source <span class="Keyword">as</span> IList&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (list != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> list.Count == 0 ? <span class="Modifier">default</span>(TSource) : list[list.Count - 1];     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; TSource last = <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; last = item;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> last;     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource LastOrDefault&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation elided</span>     <br />&#160;&#160;&#160; TSource last = <span class="Modifier">default</span>(TSource);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; last = item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> last;     <br />} </div>  <p>This time, aside from the optimization, the predicated and non-predicated forms look <em>very</em> similar... more so than for any of the other operators. In each case, we start with a return value of default(TSource), and iterate over the whole sequence, updating it - only doing so when it matches the predicate, if we&#39;ve got one.</p>  <h3>Conclusion</h3>  <p>This was a longer post than I anticipated when I got up this morning, but I hope the slight differences between implementations - and the mystery of the unoptimized predicated &quot;Last/LastOrDefault&quot; operators have made it worth slogging through.</p>  <p>As a contrast - and because I&#39;ve already mentioned it in this post - I&#39;ll implement DefaultIfEmpty next. I reckon I can still do that this evening, if I hurry...</p>  <h3>Addendum</h3>  <p>It turns out I was missing some tests for Single and SingleOrDefault: what should they do if evaluating the sequence fully throws an exception? It turns out that in LINQ to Objects, the overloads <em>without</em> a predicate throw InvalidOperationException as soon as they see a second element, but the overloads <em>with</em> a predicate keep iterating even when they&#39;ve seen a second element matching a predicate. This seems ludicrously inconsistent to me - I&#39;ve opened a <a href="https://connect.microsoft.com/VisualStudio/feedback/details/639955">Connect issue</a> about it; we&#39;ll see what happens.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
