<html>
<head>
<title>Reimplementing LINQ to Objects: Part 12 - DefaultIfEmpty</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 12 - DefaultIfEmpty</h1>
<p>After the masses of code required for all the permutations of First/Last/etc, DefaultIfEmpty is a bit of a relief.</p>  <h3>What is it?</h3>  <p>Even this simple operator has <a href="http://msdn.microsoft.com/en-us/library/bb360530.aspx" target="_blank">two overloads</a>:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource defaultValue) </div>  <p>The behaviour is very simple to describe:</p>  <ul>   <li>If the input sequence is empty, the result sequence has a single element in it, the default value. This is default(TSource) for the overload without an extra parameter, or the specified value otherwise. </li>    <li>If the input sequence isn&#39;t empty, the result sequence is the same as the input sequence </li>    <li>The source argument must not be null, and this is validated eagerly </li>    <li>The result sequence itself uses <em>deferred execution</em> - the input sequence isn&#39;t read at all until the result sequence is read </li>    <li>The input sequence is streamed; any values read are yielded immediately; no buffering is used </li> </ul>  <p>Dead easy.</p>  <h3>What are we going to test?</h3>  <p>Despite being relatively late in the day, I decided to test for argument validation - and a good job too, as my first attempt failed to split the implementation into an argument validation method and an iterator block method for the real work! It just shows how easy it is to slip up.</p>  <p>Other than that, I can really only see four cases worth testing:</p>  <ul>   <li>No default value specified, empty input sequence </li>    <li>Default value specified, empty input sequence </li>    <li>No default value specified, non-empty input sequence </li>    <li>Default value specified, non-empty input sequence </li> </ul>  <p>So I have tests for all of those, and that&#39;s it. I don&#39;t have anything testing for streaming, lazy evaluation etc.</p>  <h3>Let&#39;s implement it!</h3>  <p>Despite my reluctance to implement one operator in terms of another elsewhere, this felt like <em>such</em> an obvious case, I figured it would make sense just this once. I even applied DRY to the argument validation aspect. Here&#39;s the implementation in all its brief glory:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// This will perform an appropriate test for source being null first.</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.DefaultIfEmpty(<span class="Modifier">default</span>(TSource));     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource defaultValue)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> DefaultIfEmptyImpl(source, defaultValue);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmptyImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource defaultValue)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">bool</span> foundAny = <span class="Keyword">false</span>;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foundAny = <span class="Keyword">true</span>;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (!foundAny)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> defaultValue;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Of course, now that I&#39;ve said how easy it was, someone will find a bug...</p>  <p>Aside from the use of default(TSource) to call the more complex overload from the simpler one, the only aspect of any interest is the bottom method. It irks me slightly that we&#39;re assigning &quot;true&quot; to &quot;foundAny&quot; on every iteration... but the alternative is fairly unpleasant:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; DefaultIfEmptyImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TSource defaultValue)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> defaultValue;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>; <span class="InlineComment">// Like a &quot;return&quot;</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>This may be slightly more efficient, but it <em>feels</em> a little clumsier. We could get rid of the &quot;yield break&quot; by putting the remainder of the method in an &quot;else&quot; block, but I&#39;m not dead keen on that, either. We could use a do/while loop instead of a simple while loop - that would at least remove the repetition of &quot;yield return iterator.Current&quot; but I&#39;m not really a fan of do/while loops. I use them sufficiently rarely that they cause me more mental effort to read than I really like.</p>  <p>If any readers have suggestions which are significantly nicer than either of the above implementations, I&#39;d be interested to hear them. This feels a little inelegant at the moment. It&#39;s far from a readability disaster - it&#39;s just not quite neat.</p>  <h3>Conclusion</h3>  <p>Aside from the slight annoyance at the final lack of elegance, there&#39;s not much of interest here. However, we could now implement FirstOrDefault/LastOrDefault/SingleOrDefault using DefaultIfEmpty. For example, here&#39;s an implementation of FirstOrDefault: </p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.DefaultIfEmpty().First();    <br />}    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource FirstOrDefault&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)    <br />{    <br />&#160;&#160;&#160; <span class="InlineComment">// Can&#39;t just use source.DefaultIfEmpty().First(predicate)</span>    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Where(predicate).DefaultIfEmpty().First();    <br />} </div>  <p>Note the comment in the predicated version - the defaulting has to be the <em>very last step</em> after we&#39;ve applied the predicate... otherwise if we pass in an empty sequence and a predicate which doesn&#39;t match with default(TSource), we&#39;ll get an exception instead of the default value. The other two ...OrDefault operators could be implemented in the same way, of course. (I haven&#39;t done so yet, but the above code is in source control.)</p>  <p>I&#39;m currently unsure what I&#39;ll implement next. I&#39;ll see whether I get inspired by any particular method in the morning.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
