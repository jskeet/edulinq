<html>
<head>
<title>Reimplementing LINQ to Objects: Part 9 - SelectMany</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 9 - SelectMany</h1>
<p>The next operator we&#39;ll implement is actually the most important in the whole of LINQ. Most (all?) of the other operators returning sequences can be implemented via SelectMany. We&#39;ll have a look at that at the end of this post, but let&#39;s implement it first.</p>  <h3>What is it?</h3>  <p>SelectMany has 4 overloads, which look gradually more and more scary:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, IEnumerable&lt;TResult&gt;&gt; selector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, IEnumerable&lt;TCollection&gt;&gt; collectionSelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TCollection, TResult&gt; resultSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, IEnumerable&lt;TCollection&gt;&gt; collectionSelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TCollection, TResult&gt; resultSelector) </div>  <p>These aren&#39;t too bad though. Really these are just variations of the same operation, with two &quot;optional&quot; bits.</p>  <p>In every case, we start with an input sequence. We generate a subsequence from each element in the input sequence using a delegate which can optionally take a parameter with the index of the element within the original collection.</p>  <p>Now, we <em>either</em> return each element from each subsequence directly, <em>or</em> we apply another delegate which takes the original element in the input sequence and the element within the subsequence.</p>  <p>In my experience, uses of the overloads where the original selector delegate uses the index are pretty rare - but the others (the first and the third in the list above) are fairly common. In particular, the C# compiler uses the third overload whenever it comes across a &quot;from&quot; clause in a query expression, other than the very first &quot;from&quot; clause.</p>  <p>It helps to put this into a bit more context. Suppose we have a query expression like this:</p>  <div class="code"><span class="Linq">var</span> query = <span class="Linq">from</span> file <span class="Statement">in</span> Directory.GetFiles(<span class="String">&quot;logs&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">from</span> line <span class="Statement">in</span> File.ReadLines(file)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> Path.GetFileName(file) + <span class="String">&quot;: &quot;</span> + line; </div>  <p>That would be converted into a &quot;normal&quot; call like this: </p>  <div class="code"><span class="Linq">var</span> query = Directory.GetFiles(<span class="String">&quot;logs&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .SelectMany(file =&gt; File.ReadLines(file),     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (file, line) =&gt; Path.GetFileName(file) + <span class="String">&quot;: &quot;</span> + line); </div>  <p>In this case the compiler has used our final &quot;select&quot; clause as the projection; if the query expression had continued with &quot;where&quot; clauses etc, it would have created a projection to just pass along &quot;file&quot; and &quot;line&quot; in an anonymous type. This is probably the most confusing bit of the query translation process, involving <em>transparent identifiers</em>. For the moment we&#39;ll stick with the simple version above.</p>  <p>So, the SelectMany call above has three arguments really:</p>  <ul>   <li>The source, which is a list of strings (the filenames returned from Directory.GetFiles) </li>    <li>An initial projection which converts from a single filename to a list of the lines of text within that file </li>    <li>A final projection which converts a (file, line) pair into a single string, just by separating them with &quot;: &quot;. </li> </ul>  <p>The result is a single sequence of strings - every line of every log file, prefixed with the filename in which it appeared. So writing out the results of the query might give output like this:</p>  <div class="code">test1.log: foo    <br />test1.log: bar     <br />test1.log: baz     <br />test2.log: Second log file     <br />test2.log: Another line from the second log file </div>  <p>It can take a little while to get your head round SelectMany - at least it did for me - but it&#39;s a really important one to understand.</p>  <p>A few more details of the behaviour before we go into testing:</p>  <ul>   <li>The arguments are validated eagerly - everything has to be non-null. </li>    <li><em>Everything</em> is streamed. So only one element of the input is read at a time, and then a subsequence is produced from that. Only one element is then read from the subsequence at a time, yielding the results as we go, before we move onto the next input element and thus the next subsequence etc. </li>    <li>Every iterator is closed when it&#39;s finished with, just as you&#39;d expect by now. </li> </ul>  <h3>What are we going to test?</h3>  <p>I&#39;m afraid I&#39;ve become lazy by this point. I can&#39;t face writing yet <em>more</em> tests for null arguments. I&#39;ve written a single test for each of the overloads. I found it hard to come up with a clear way of writing the tests, but here&#39;s one example, for the most complicated overload:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> FlattenWithProjectionAndIndex()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] numbers = { 3, 5, 20, 15 };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = numbers.SelectMany((x, index) =&gt; (x + index).ToString().ToCharArray(),     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (x, c) =&gt; x + <span class="String">&quot;: &quot;</span> + c);     <br />&#160;&#160;&#160; <span class="InlineComment">// 3 =&gt; &quot;3: 3&quot;</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// 5 =&gt; &quot;5: 6&quot;</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// 20 =&gt; &quot;20: 2&quot;, &quot;20: 2&quot;</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// 15 =&gt; &quot;15: 1&quot;, &quot;15: 8&quot;</span>     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;3: 3&quot;</span>, <span class="String">&quot;5: 6&quot;</span>, <span class="String">&quot;20: 2&quot;</span>, <span class="String">&quot;20: 2&quot;</span>, <span class="String">&quot;15: 1&quot;</span>, <span class="String">&quot;15: 8&quot;</span>);     <br />} </div>  <p>So, to give a bit more explanation to this:</p>  <ul>   <li>Each number is summed with its index (3+0, 5+1, 20+2, 15+3) </li>    <li>Each sum is turned into a string, and then converted into a char array. (We don&#39;t really need to ToCharArray call as string implements IEnumerable&lt;char&gt; already, but I thought it made it clearer.) </li>    <li>We combine each subsequence character with the original element it came from, in the form: &quot;original value: subsequence character&quot; </li> </ul>  <p>The comment shows the eventual results from each input, and the final test shows the complete result sequence.</p>  <p>Clear as mud? Hopefully it&#39;s not to bad when you look at each step in turn. Okay, now let&#39;s make it pass...</p>  <h3>Let&#39;s implement it!</h3>  <p>We <em>could</em> implement the first three overloads in terms of calls to the final one - or more likely, a single &quot;Impl&quot; method without argument validation, called by all four public methods. For example, the simplest method <em>could</em> be implemented like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (selector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;selector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> SelectManyImpl(source,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (value, index) =&gt; selector(value),     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (originalElement, subsequenceElement) =&gt; subsequenceElement);     <br />} </div>  <p>However, I&#39;ve decided to implement each of the methods separately - splitting them into the public extension method and a &quot;SelectManyImpl&quot; method with the same signature each time. I think that would make it simpler to step through the code if there were ever any problems... and it allows us to see the differences between the simplest and most complicated versions, too:</p>  <div class="code"><span class="InlineComment">// Simplest overload</span>     <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectManyImpl&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (TResult result <span class="Statement">in</span> selector(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> result;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="InlineComment">// Most complicated overload:</span>     <br /><span class="InlineComment">// - Original projection takes index as well as value</span>     <br /><span class="InlineComment">// - There&#39;s a second projection for each original/subsequence element pair</span>     <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectManyImpl&lt;TSource, TCollection, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, IEnumerable&lt;TCollection&gt;&gt; collectionSelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TCollection, TResult&gt; resultSelector)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index = 0;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (TCollection collectionItem <span class="Statement">in</span> collectionSelector(item, index++))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> resultSelector(item, collectionItem);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The correspondence between the two methods is pretty clear... but I find it helpful to <em>have</em> the first form, so that if I ever get confused about the fundamental point of SelectMany, it&#39;s really easy to understand it based on the simple overload. It&#39;s then not too big a jump to apply the two extra &quot;optional&quot; complications, and end up with the final method. The simple overload acts as a conceptual stepping stone, in a way.</p>  <p>Two minor points to note:</p>  <ul>   <li>The first method could have been implemented with a &quot;yield foreach selector(item)&quot; if such an expression existed in C#. Using a similar construct in the more complicated form would be harder, and involve another call to Select, I suspect... probably more hassle than it would be worth. </li>    <li>I&#39;m not explicitly using a &quot;checked&quot; block in the second form, even though &quot;index&quot; could overflow. I haven&#39;t looked to see what the BCL does in this situation, to be honest - I think it unlikely that it will come up. For consistency I should probably use a checked block on <em>every</em> method which uses an index like this... or just turn arithmetic checking on for the whole assembly. </li> </ul>  <h3>Reimplementing operators using SelectMany</h3>  <p>I mentioned early on in this post that many of the LINQ operators can be implemented via SelectMany. Just as a quick example of this, here are alternative implementations of Select, Where and Concat:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Select&lt;TSource, TResult&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; Func&lt;TSource, TResult&gt; selector)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">if</span> (selector == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;selector&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.SelectMany(x =&gt; Enumerable.Repeat(selector(x), 1));    <br />}    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.SelectMany(x =&gt; Enumerable.Repeat(x, predicate(x) ? 1 : 0));    <br />}    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (first == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;first&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">if</span> (second == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;second&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span>[] { first, second }.SelectMany(x =&gt; x);    <br />} </div>  <p>Select and Where use Enumerable.Repeat as a convenient way of creating a sequence with either a single element or none. You could alternatively create a new array instead. Concat just uses an array directly: if you think of SelectMany in terms of its flattening operation, Concat is a really natural fit. I suspect that Empty and Repeat are probably feasible with recursion, although the performance would become absolutely horrible.</p>  <p>Currently the above implementations are in the code using conditional compilation. If this becomes a popular thing for me to implement, I might consider breaking it into a separate project. Let me know what you think - my gut feeling is that we won&#39;t actually gain much more insight than the above methods give us... just showing how flexible SelectMany is.</p>  <p>SelectMany is also important in a theoretical way, in that it&#39;s what provides the <em>monadic</em> nature of LINQ. It&#39;s the &quot;Bind&quot; operation in the LINQ monad. I don&#39;t intend to say any more than that on the topic - read <a href="http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx" target="_blank">Wes Dyer&#39;s blog post</a> for more details, or just search for &quot;bind monad SelectMany&quot; for plenty of posts from people smarter than myself.</p>  <h3>Conclusion</h3>  <p>SelectMany is one of LINQ&#39;s fundamental operations, and at first sight it&#39;s a fearsome beast. As soon as you understand that the basic operation is a flattening projection just with a couple of optional twiddles, it&#39;s easily tamed.</p>  <p>Next up I&#39;ll implement All and Any - which are nice and easy to describe by comparison.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
