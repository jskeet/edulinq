<html>
<head>
<title>Reimplementing LINQ to Objects: Part 30 - Average</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 30 - Average</h1>
<p>This is the final aggregation operator, after which I suspect we won&#39;t need to worry about floating point difficulties any more. Between this and the unexpected behaviour of Comparer&lt;string&gt;.Default, I&#39;ve covered two of my &quot;big three&quot; pain points. It&#39;s hard to see how I could get dates and times into Edulinq naturally; it&#39;s even harder to see how time zones could cause problems. I&#39;ve still got a few operators to go though, so you never know...</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.average.aspx">Average</a> has 20 overloads, all like the following but for long, decimal, float and double as well as int:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span> Average(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span> Average&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>&gt; selector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span>? Average(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span>? Average&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>?&gt; selector) </div>  <p>The operators acting on float sequences return float, and likewise the operators acting on decimal sequences return decimal, with the same equivalent nullable types for the nullable sequences.</p>  <p>As before (for Min/Max/Sum), the overloads which take a selector are equivalent to just applying that selector to each element in the sequence.</p>  <p>General behaviour - pretty much as you&#39;d expect, I suspect:</p>  <ul>   <li>Each operator calculates the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of a sequence of values. </li>    <li>source and selector can&#39;t be null, and are validated immediately. </li>    <li>The operators all use <em>immediate execution</em>. </li>    <li>The operators all iterate over the entire input sequence, unless an exception is thrown (e.g. due to overflow). </li>    <li>The operators with a non-nullable return type throw InvalidOperationException if the input sequence is empty. </li>    <li>The operators with a nullable return type ignore any null input values, and return null if the input sequence is empty or contains only null values. If non-null values are present, the return value will be non-null. </li> </ul>  <p>It all sounds pretty simple, doesn&#39;t it? We just sum the numbers, and divide by the count. It&#39;s not <em>too</em> complicated, but we have a couple of things to consider:</p>  <ul>   <li>How should we count items - which data type should we use? Do we need to cope with more than int.MaxValue elements? </li>    <li>How should we sum items? Should we be able to find the average of { int.MaxValue, int.MaxValue } even though the sum clearly overflows the bounds of int? </li> </ul>  <p>Given the behaviour of my tests, I believe I&#39;ve made the same decisions. I use a long for the counter, always. I use a long total for the int/long overloads, a double total for the float/double overloads, and a decimal total for the decimal overloads. These aren&#39;t particularly tricky decisions once you&#39;d realised that you need to make them, but it would be very easy to implement the operators in a simplistic way without thinking about such things. (I&#39;d probably have done so if it weren&#39;t for the comments around Sum this morning.)</p>  <h3>What are we going to test?</h3>  <p>I&#39;ve only got in-depth tests for the int overloads, covering:</p>  <ul>   <li>Argument validation </li>    <li>Empty sequences for nullable and non-nullable types </li>    <li>Sequences with only null values </li>    <li>Sequences of perfectly normal values :) </li>    <li>Projections for all the above </li>    <li>A sequence with just over int.MaxValue elements, to test we can count properly </li> </ul>  <p>Then I have a few extra tests for interesting situations. First I check the overflow behaviour of each type, using a common pattern of averaging a sequence of (max, max, -max, -max) where &quot;max&quot; is the maximum value for the sequence type. The results are:</p>  <ul>   <li>For int we get the correct result of 0 because we&#39;re accumulating over longs </li>    <li>For long we get an OverflowException when it tries to add the first two values together </li>    <li>For float we get the correct result of 0 because we&#39;re accumulating over doubles </li>    <li>For double we get PositiveInfinity because that&#39;s the result of the first addition </li>    <li>For decimal we get an OverflowException when it tries to add the first two values together </li> </ul>  <p>Additionally, I have a couple of floating-point-specific tests: namely further proof that we use a double accumulator when averaging floats, and the behaviour of Average in the presence of NaN values:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SingleUsesDoubleAccumulator()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// All the values in the array are exactly representable as floats,</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// as is the correct average... but intermediate totals aren&#39;t.</span>     <br />&#160;&#160;&#160; <span class="ValueType">float</span>[] array = { 20000000f, 1f, 1f, 2f };     <br />&#160;&#160;&#160; Assert.AreEqual(5000001f, array.Average());     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SequenceContainingNan()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">double</span>[] array = { 1, 2, 3, <span class="ValueType">double</span>.NaN, 4, 5, 6 };     <br />&#160;&#160;&#160; Assert.IsNaN(array.Average());     <br />} </div>  <p>I&#39;m sure someone can think of some other interesting scenarios I should be considering :)</p>  <h3>Let&#39;s implement it!</h3>  <p>This is another cut-and-paste job, but with more editing required - for each method, I needed to make sure I was using the right accumulator type, and I occasionally removed redundant casts. Still, the code follows pretty much the same pattern for all types. Here&#39;s the int implementation:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span> Average(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">long</span> count = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">long</span> total = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ValueType">int</span> item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; total += item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; count++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (count == 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> (<span class="ValueType">double</span>)total / (<span class="ValueType">double</span>)count;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span> Average&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Select(selector).Average();     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span>? Average(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">long</span> count = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">long</span> total = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ValueType">int</span>? item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (item != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; count++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; total += item.Value;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> count == 0 ? (<span class="ValueType">double</span>?)<span class="Keyword">null</span> : (<span class="ValueType">double</span>)total / (<span class="ValueType">double</span>)count;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">double</span>? Average&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>?&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Select(selector).Average();     <br />} </div>  <p>Salient points:</p>  <ul>   <li>Again I&#39;m using Select to make the implementation of the overloads with selectors trivial </li>    <li>I&#39;ve cast <em>both</em> operands of the division when calculating the average, just for clarity. We could get away with either of them. </li>    <li>In the case of the conditional operator, I could actually <em>just</em> cast one of the division operators to &quot;double?&quot; and then remove <em>both</em> of the other casts... again, I feel this version is clearer. (I could change my mind tomorrow, mind you...) </li>    <li>I&#39;ve explicitly used checked blocks for int and long. For float and double we won&#39;t get overflow anyway, and for decimal the checked/unchecked context is irrelevant. </li> </ul>  <p>There&#39;s one optimization we can perform here. Consider this loop, for the nullable sequence:</p>  <div class="code"><span class="ValueType">long</span> count = 0;     <br /><span class="ValueType">long</span> total = 0;     <br /><span class="Statement">foreach</span> (<span class="ValueType">int</span>? item <span class="Statement">in</span> source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (item != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; count++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; total += item.Value; <span class="InlineComment">// This line can be optimized...</span>     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The line I&#39;ve highlighted seems perfectly reasonable, right? We&#39;re trying to add the &quot;real&quot; non-null value within a value type value, and we know that there <em>is</em> a real value, because we&#39;ve checked it&#39;s not the null value already.</p>  <p>Now think about what the Value property actually does... it checks whether or not it&#39;s the null value, and then returns the real value or throws an exception. But we <em>know</em> it won&#39;t throw an exception, because we&#39;ve checked it. We just want to get at the value - don&#39;t bother with any more checks. <em>That&#39;s exactly what <a href="http://msdn.microsoft.com/en-us/library/72cec0e0.aspx">GetValueOrDefault()</a> does</em>. In the case where the value is non-null, GetValueOrDefault() and the Value property obviously do the same thing - but intuition tells me that GetValueOrDefault() can do it quicker, because it doesn&#39;t actually need to check anything. It can just return the value of the underlying field - which will be the default value of the underlying type for a null wrapper value anyway.</p>  <p>I&#39;ve benchmarked this, and on my laptop it&#39;s about 5% faster than using Value. But... it&#39;s such a grotty hack. I would feel dirty putting it in. Surely Value is the more readable code here - it just happens to be slower. As always, I&#39;m undecided. There&#39;s no behavioural difference, just a slight speed boost. Thoughts, folks?</p>  <h3>Conclusion</h3>  <p>I&#39;m quite pleased to be shot of the Aggregate Operators Of Overload Doom. I&#39;ve felt for a while that they&#39;ve been hanging over me - I knew they&#39;d be annoying in terms of cut and paste, but there&#39;s been more interesting situations to consider than I&#39;d expected.</p>  <p>There&#39;s not a lot left now. According to my <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/02/reimplementing-linq-to-objects-part-23-take-skip-takewhile-skipwhile.aspx">previous list</a>, I&#39;ve got:</p>  <ul>   <li>Cast and OfType </li>    <li>ElementAt and ElementAtOrDefault </li>    <li>SequenceEqual </li>    <li>Zip (from .NET 4) </li>    <li>Contains </li> </ul>  <p>However, that doesn&#39;t include AsEnumerable and AsQueryable. I&#39;m unsure at the moment what I&#39;m doing with those... AsEnumerable is trivial, and probably worth doing... AsQueryable could prove interesting in terms of testing, as it requires expression trees (which are in System.Core; a library I&#39;m not referencing from tests when testing the Edulinq implementation). I&#39;ll play around and see what happens :)</p>  <p>Not sure what I&#39;ll implement next, to be honest... we&#39;ll see tomorrow!</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
