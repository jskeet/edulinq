<html>
<head>
<title>Reimplementing LINQ to Objects: Part 17 - Except</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 17 - Except</h1>
<p>I&#39;m really pleased with this one. Six minutes ago (at the time of writing this), I tweeted about the Intersect blog post. I then <em>started</em> writing the tests and implementation for Except... and I&#39;m now done.</p>  <p>The tests are cut/paste/replace with a few tweaks - but it&#39;s the implementation that I&#39;m most pleased with. You&#39;ll see what I mean later - it&#39;s beautiful.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.except.aspx" target="_blank">Except</a> is our final set operator, with the customary two overloads:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Except&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer) </div>  <p>The result of calling Except is the elements of the first sequence which are <em>not</em> in the second sequence.</p>  <p>Just for completeness, here&#39;s a quick summary of the behaviour:</p>  <ul>   <li>The first overload uses the default equality comparer for TSource, and the second overload does if you pass in &quot;null&quot; as the comparer, too. </li>    <li>Neither &quot;first&quot; nor &quot;second&quot; can be null </li>    <li>The method <em>does</em> use deferred execution </li>    <li>The result sequence only contains distinct elements; even if the first sequence contains duplicates, the result sequence won&#39;t </li> </ul>  <p>This time, the documentation doesn&#39;t say how &quot;first&quot; and &quot;second&quot; will be used, other than to describe the result as a set difference. In practice though, it&#39;s exactly the same as Intersect: when we ask for the first result, the &quot;second&quot; input sequence is fully evaluated, then the &quot;first&quot; input sequence is streamed.</p>  <h3>What are we going to test?</h3>  <p>I literally cut and paste the tests for Intersect, did a find/replace on Intersect/Except, and then looked at the data in each test. In particular, I made sure that there were potential duplicates in the &quot;first&quot; input sequence which would have to be removed in the result sequence. I also tweaked the <em>details</em> of the data in the final tests shown before (which proved the way in which the two sequences were read) but the main thrust of the tests are the same.</p>  <p>Nothing to see here, move on...</p>  <h3>Let&#39;s implement it!</h3>  <p>I&#39;m not even going to bother showing the comparer-free overload this time. It just calls the other overload, as you&#39;d expect. Likewise the argument validation part of the implementation is tedious. Let&#39;s focus on the part which does the work. First, we&#39;ll think back to Distinct and Intersect:</p>  <ul>   <li>In Distinct, we started with an empty set and populated it as we went along, making sure we never returned anything already in the set </li>    <li>In Intersect, we started with a populated set (from the second input sequence) and <em>removed</em> elements from it as we went along, <em>only</em> returning elements where an equal element was previously in the set </li> </ul>  <p>Except is simply a cross between the two: from Distinct we keep the idea of a &quot;banned&quot; set of elements that we add to; from Intersect we take the idea of starting off with a set populated from the second input element. Here&#39;s the implementation:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ExceptImpl&lt;TSource&gt;(    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{    <br />&#160;&#160;&#160; HashSet&lt;TSource&gt; bannedElements = <span class="Keyword">new</span> HashSet&lt;TSource&gt;(second, comparer);    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> first)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (bannedElements.Add(item))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />} </div>  <p>The only differences between this and Intersect are:</p>  <ul>   <li>The name of the method (ExceptImpl instead of IntersectImpl)</li>    <li>The name of the local variable holding the set (bannedElements instead of potentialElements)</li>    <li>The method called in the loop (Add instead of Remove)</li> </ul>  <p>Isn&#39;t that just <em>wonderful</em>? Perhaps it shouldn&#39;t make me quite as happy as it does, but hey...</p>  <h3>Conclusion</h3>  <p>That concludes the set operators - and indeed my blogging for the night. It&#39;s unsurprising that all of the set operators have used a set implementation internally... but I&#39;ve been quite surprised at just how simple the implementations all were. Again, the joy of LINQ resides in the ability for such simple operators to be combined in useful ways.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
