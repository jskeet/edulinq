<html>
<head>
<title>Reimplementing LINQ to Objects: Part 8 - Concat</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 8 - Concat</h1>
<p>After our quick visit to scalar return types with Count and LongCount, we&#39;re back to an operator returning a sequence: Concat.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb302894.aspx" target="_blank">Concat</a> only has a single signature, which makes life simple:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second) </div>  <p>The return value is simply a sequence containing the elements of the first sequence followed by the elements of the second sequence - the <em>concatenation</em> of the two sequences.</p>  <p>I sometimes think it&#39;s a pity that there aren&#39;t Prepend/Append methods which do the same thing but for a single extra element - this would be quite useful in situations such as having a drop down list of countries with an extra option of &quot;None&quot;. It&#39;s easy enough to use Concat for this purpose by creating a single-element array, but specific methods would be more readable in my view. <a href="http://code.google.com/p/morelinq/" target="_blank">MoreLINQ</a> has extra <a href="http://code.google.com/p/morelinq/source/browse/trunk/MoreLinq/Concat.cs?r=171" target="_blank">Concat methods</a> for this purpose, but Edulinq is only meant to implement the methods already in LINQ to Objects.</p>  <p>As ever, some notes on the behaviour of Concat:</p>  <ul>   <li>Arguments are validated eagerly: they must both be non-null </li>    <li>The result uses deferred execution: other than validation, the arguments aren&#39;t used when the method is first called </li>    <li>Each sequence is only evaluated when it needs to be... if you stop iterating over the output sequence before the first input has been exhausted, the second input will remain unused </li> </ul>  <p>That&#39;s basically it.</p>  <h3>What are we going to test?</h3>  <p>The actual concatenation part of the behaviour is very easy to test in a single example - we could potentially also demonstrate concatenation using empty sequences, but there&#39;s no reason to suspect they would fail.</p>  <p>The argument validation is tested in the same way as normal, by calling the method with invalid arguments but not attempting to use the returned query.</p>  <p>Finally, there are a couple of tests to indicate the point at which each input sequence is used. This is achieved using the ThrowingEnumerable we originally used in the Where tests:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> FirstSequenceIsntAccessedBeforeFirstUse()     <br />{     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ValueType">int</span>&gt; first = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ValueType">int</span>&gt; second = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[] { 5 };     <br />&#160;&#160;&#160; <span class="InlineComment">// No exception yet...</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = first.Concat(second);     <br />&#160;&#160;&#160; <span class="InlineComment">// Still no exception...</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Now it will go bang</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; iterator.MoveNext());     <br />&#160;&#160;&#160; }     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SecondSequenceIsntAccessedBeforeFirstUse()     <br />{     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ValueType">int</span>&gt; first = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[] { 5 };     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ValueType">int</span>&gt; second = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; <span class="InlineComment">// No exception yet...</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = first.Concat(second);     <br />&#160;&#160;&#160; <span class="InlineComment">// Still no exception...</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// First element is fine...</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.IsTrue(iterator.MoveNext());     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(5, iterator.Current);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Now it will go bang, as we move into the second sequence</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; iterator.MoveNext());     <br />&#160;&#160;&#160; }     <br />} </div>  <p>I haven&#39;t written tests to check that iterators are disposed, etc - but each input sequence&#39;s iterator should be disposed appropriately. In particular, it&#39;s natural for the first sequence&#39;s iterator to be disposed before the second sequence is iterated over at all.</p>  <h3>Let&#39;s impement it!</h3>  <p>The implementation is reasonably simple, but it does make me hanker after F#... it&#39;s the normal split between argument validation and iterator block implementation, but each part is really simple:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (first == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;first&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (second == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;second&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ConcatImpl(first, second);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ConcatImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> first)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> second)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>It&#39;s worth just remembering at this point that this would still have been very annoying to implement without iterator blocks. Not really <em>difficult</em> as such, but we&#39;d have had to remember which sequence we were currently iterating over (if any) and so on.</p>  <p>However, using F# we could have made this even simpler with the <code>yield!</code> expression, which yields a whole sequence instead of a single item. Admittedly in this case there aren&#39;t significant performance benefits to using <code>yield!</code> (which there certainly can be in recursive situations) but it would just be more elegant to have the ability to yield an entire sequence in one statement. (Spec# has a similar construct called <em>nested iterators</em>, expressed using <a href="http://research.microsoft.com/en-us/projects/specsharp/iterators.pdf" target="_blank"><code>yield foreach</code></a>.) I&#39;m not going to pretend to know enough about the details of either F# or Spec# to draw more detailed comparisons, but we&#39;ll see the pattern of &quot;foreach item in a collection, yield the item&quot; several more times before we&#39;re done. Remember that we <em>can&#39;t</em> extract that into a library method, as the &quot;yield&quot; expression needs special treatment by the C# compiler.</p>  <h3>Conclusion</h3>  <p>Even when presented with a simple implementation, I can still find room to gripe :) It would be nice to have nested iterators in C#, but to be honest the number of times I find myself frustrated by their absence is pretty small.</p>  <p>Concat is a useful operator, but it&#39;s really only a very simple specialization of another operator: SelectMany. After all, Concat just flattens two sequences into one... whereas SelectMany can flatten a whole sequence of sequences, with even more generality available when required. I&#39;ll implement SelectMany next, and show a few examples of how other operators can be implemented simply in terms of SelectMany. (We&#39;ll see the same sort of ability for operators returning a single value when we implement Aggregate.)</p>  <h3>Addendum: avoiding holding onto references unnecessarily</h3>  <p>A comment suggested that we should set first to &quot;null&quot; after we&#39;ve used it. That way, as soon as we&#39;ve finished iterating over the collection, it may be eligible for garbage collection. That leads to an implementation like this:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ConcatImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> first)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// Avoid hanging onto a reference we don&#39;t really need</span>     <br />&#160;&#160;&#160; first = <span class="Keyword">null</span>;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> second)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Now normally I&#39;d say this wouldn&#39;t actually help - setting a local variable to null when it&#39;s not used in the rest of the method doesn&#39;t actually make any difference when the CLR is running in optimized mode, without a debugger attached: the garbage collector only cares about variables whih <em>might</em> still be accessed in the rest of the method. </p>  <p>In this case, however, it makes a difference - because this <em>isn&#39;t</em> a normal local variable. It ends up as an instance variable in the hidden class generated by the C# compiler... and the CLR can&#39;t tell that the instance variable will never be used again.</p>  <p>Arguably we <em>could</em> remove our only reference to &quot;first&quot; at the start of GetEnumerator. We could write a method of the form:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> T ReturnAndSetToNull&lt;T&gt;(<span class="MethodParameter">ref</span> T value) <span class="Linq">where</span> T : <span class="ReferenceType">class</span>    <br />{    <br />&#160;&#160;&#160; T tmp = value;    <br />&#160;&#160;&#160; value = <span class="Keyword">null</span>;    <br />&#160;&#160;&#160; <span class="Statement">return</span> tmp;    <br />} </div>  <p>and then call it like this:</p>  <div class="code"><span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> ReturnAndSetToNull(<span class="MethodParameter">ref</span> first)) </div>  <p>I would certainly consider that overkill, particularly as it seems very likely that the iterator will still have a reference to the collection itself - but simply setting &quot;first&quot; to null after iterating over it makes sense to me.</p>  <p>I don&#39;t <em>believe</em> that the &quot;real&quot; LINQ to Objects implementation does this, mind you. (At some point I&#39;ll test it with a collection which has a finalizer.)</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
