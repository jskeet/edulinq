<html>
<head>
<title>Reimplementing LINQ to Objects: Part 26c - Optimizing OrderedEnumerable</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 26c - Optimizing OrderedEnumerable</h1>
<p>Part 26b left us with a working implementation of the ordering operators, with two caveats:</p>  <ul>   <li>The sort algorithm used was awful </li>    <li>We were performing the key selection on every comparison, instead of once to start with </li> </ul>  <p>Today&#39;s post is just going to fix the first bullet - although I&#39;m pretty sure that fixing the second will require changing it again completely.</p>  <h3>Choosing a sort algorithm</h3>  <p>There are <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">lots of sort algorithms available</a>. In our case, we need the eventual algorithm to:</p>  <ul>   <li>Work on arbitrary pair-based comparisons </li>    <li>Be stable </li>    <li>Go like the clappers :) </li>    <li>(Ideally) allow the first results to be yielded without performing <em>all</em> the sorting work, and without affecting the performance in cases where we <em>do</em> need all the results. </li> </ul>  <p>The final bullet it an interesting one to me: it&#39;s far from unheard of to want to get the &quot;top 3&quot; results from an ordered query. In LINQ to Objects we can&#39;t easily tell the Take operator about the OrderBy operator so that it could pass on the information, but we <em>can</em> potentially yield the first results before we&#39;ve sorted everything. (In fact, we could add an extra interface specifically to enable this scenario, but it&#39;s not part of normal LINQ to Objects, and could introduce horrible performance effects with innocent-looking query changes.)</p>  <p><em>If</em> we decide to implement sorting in terms of a naturally stable algorithm, that limits the choices significantly. I was rather interested in <a href="http://en.wikipedia.org/wiki/Timsort">timsort</a>, and may one day set about implementing it - but it looked far too complicated to introduce just for the sake of Edulinq.</p>  <p>The best bet seemed to be <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a>, which is reasonably easy to implement and has reasonable efficiency too. It requires extra memory and a fair amount of copying, but we can probably cope with that.</p>  <p>We don&#39;t <em>have</em> to use a stable sort, of course. We could easily regard our &quot;key&quot; as the user-specified key plus the original index, and use that index as a final tie-breaker when comparing elements. That gives a stable <em>result</em> while allowing us to use any sorting algorithm we want. This may well be the approach I take eventually - especially as <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a> would allow us to start yielding results early in a fairly simple fashion. For the moment though, I&#39;ll stick with merge sort.</p>  <h3>Preparing for merge sort</h3>  <p>Just looking from the algorithm for merge sort, it&#39;s obvious that there will be a good deal of shuffling data around. As we want to make the implementation as fast as possible, that means it makes sense to use arrays to store the data. We don&#39;t need dynamic space allocation (after we&#39;ve read all the data in, anyway) or any of the other features associated with higher-level collections. I&#39;m aware that arrays are considered (somewhat) harmful, but purely for the internals of an algorithm which does so much data access, I believe they&#39;re the most appropriate solution.</p>  <p>We don&#39;t even need our arrays to be the right size - assuming we need to read in all the data before we start processing it (which will be true for this implementation of merge sort, but not for some other algorithms I may consider in the future) it&#39;s fine to use an oversized array as temporary storage - it&#39;s never going to be seen by the users, after all.</p>  <p>We&#39;ve already got code which reads in all the data into a possibly-oversized array though - in the optimized ToArray code. So my first step was to extract out that functionality into a new <em>internal</em> extension method. This has to return a buffer containing all the data <em>and</em> give us an indication of the size. In .NET 4 I could use Tuple to return both pieces of data, but we can also just use an out parameter - I&#39;ve gone for the latter approach at the moment. Here&#39;s the ToBuffer extension method:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="Modifier">static</span> TSource[] ToBuffer&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source, <span class="MethodParameter">out</span>&#160;<span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Optimize for ICollection&lt;T&gt;</span>     <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; collection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (collection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; count = collection.Count;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource[] tmp = <span class="Keyword">new</span> TSource[count];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; collection.CopyTo(tmp, 0);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> tmp;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// We&#39;ll have to loop through, creating and copying arrays as we go</span>     <br />&#160;&#160;&#160; TSource[] ret = <span class="Keyword">new</span> TSource[16];     <br />&#160;&#160;&#160; <span class="ValueType">int</span> tmpCount = 0;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Need to expand...</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (tmpCount == ret.Length)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Resize(<span class="MethodParameter">ref</span> ret, ret.Length * 2);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret[tmpCount++] = item;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; count = tmpCount;     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>Note that I&#39;ve used a local variable to keep track of the count in the loop near the end, only copying it into the output variable just before returning. This is due to a possibly-unfounded performance concern: we don&#39;t know where the variable will actually &quot;live&quot; in storage - and I&#39;d rather not cause some arbitrary page of heap memory to be required all the way through the loop. This is a gross case of micro-optimization without evidence, and I&#39;m tempted to remove it... but I thought I&#39;d at least share my thinking.</p>  <p>This is only an internal API, so I&#39;m trusting callers not to pass me a null &quot;source&quot; reference. It&#39;s possible that it would be a useful operator to expose at some point, but not just now. (If it were public, I would <em>definitely</em> use a local variable in the loop - otherwise callers could get weird effects by passing in a variable which could be changed elsewhere - such as due to side-effects within the loop. That&#39;s a totally avoidable problem, simply by using a local variable. For an internal API, I just need to make sure that I don&#39;t do anything so silly.)</p>  <p>Now ToArray needs to be changed to call ToBuffer, which is straightforward:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource[] ToArray&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count;     <br />&#160;&#160;&#160; TSource[] ret = source.ToBuffer(<span class="MethodParameter">out</span> count);     <br />&#160;&#160;&#160; <span class="InlineComment">// Now create another copy if we have to, in order to get an array of the</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// right size</span>     <br />&#160;&#160;&#160; <span class="Statement">if</span> (count != ret.Length)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Resize(<span class="MethodParameter">ref</span> ret, count);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />} </div>  <p>then we can prepare our OrderedEnumerable.GetEnumerator method for merging:</p>  <div class="code"><span class="Modifier">public</span> IEnumerator&lt;TElement&gt; GetEnumerator()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// First copy the elements into an array: don&#39;t bother with a list, as we</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// want to use arrays for all the swapping around.</span>     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count;     <br />&#160;&#160;&#160; TElement[] data = source.ToBuffer(<span class="MethodParameter">out</span> count);     <br />&#160;&#160;&#160; TElement[] tmp = <span class="Keyword">new</span> TElement[count];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; MergeSort(data, tmp, 0, count - 1);     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; count; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> data[i];     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The &quot;tmp&quot; array is for use when merging - while there <em>is</em> an in-place merge sort, it&#39;s more complex than the version where the &quot;merge&quot; step merges two sorted lists into a combined sorted list in temporary storage, then copies it back into the original list.</p>  <p>The arguments of 0 and count - 1 indicate that we want to sort the whole list - the parameters to my MergeSort method take the &quot;left&quot; and &quot;right&quot; boundaries of the sublist to sort - both of which are inclusive. Most of the time I&#39;m more used to using exclusive upper bounds, but all the algorithm descriptions I found used inclusive upper bounds - so it made it easier to stick with that than try to &quot;fix&quot; the algorithm to use exclusive upper bounds everywhere. I think it highly unlikely that I&#39;d get it all right without any off-by-one errors :)</p>  <p>Now all we&#39;ve got to do is write an appropriate MergeSort method, and we&#39;re done.</p>  <h3>Implementing MergeSort</h3>  <p>I won&#39;t go through the <em>details</em> of how a merge sort works - read the <a href="http://en.wikipedia.org/wiki/Merge_sort">wikipedia article</a> for a pretty good description. In brief though, the MergeSort method guarantees that it will leave the specified portion of the input data sorted. It does this by splitting that section in half, and recursively merge sorting each half. It then merges the two halves by walking along two cursors (one from the start of each subsection) finding the smallest element out of the two at each point, copying that element into the temporary array and advancing just that cursor. When it&#39;s finished, the temporary storage will contain the sorted section, and it&#39;s copied back to the &quot;main&quot; array. The recursion has to stop at some point, of course - and in my implementation it stops if the section has fewer than three elements.</p>  <p>Here&#39;s the MergeSort method itself first:</p>  <div class="code"><span class="InlineComment">// Note: right is *inclusive*</span>     <br /><span class="Modifier">private</span>&#160;<span class="ValueType">void</span> MergeSort(TElement[] data, TElement[] tmp, <span class="ValueType">int</span> left, <span class="ValueType">int</span> right)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (right &gt; left)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (right == left + 1)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TElement leftElement = data[left];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TElement rightElement = data[right];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (currentComparer.Compare(leftElement, rightElement) &gt; 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; data[left] = rightElement;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; data[right] = leftElement;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> mid = left + (right - left) / 2;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; MergeSort(data, tmp, left, mid);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; MergeSort(data, tmp, mid + 1, right);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Merge(data, tmp, left, mid + 1, right);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p><font style="font-weight:normal;">The test for &quot;right &gt; left&quot; is part of a vanilla merge sort (if the section either has one element or none, we don&#39;t need to take any action), but I&#39;ve optimized the common case of only two elements. All we need to do is swap the elements - and even then we only need to do so if they&#39;re currently in the wrong order. There&#39;s no point in setting up all the guff of the two cursors - or even have the slight overhead of a method call - for that situation.</font></p>  <p>Other than that one twist, this is a pretty standard merge sort. Now for the Merge method, which is slightly more complicated (although still <em>reasonably</em> straighforward):</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="ValueType">void</span> Merge(TElement[] data, TElement[] tmp, <span class="ValueType">int</span> left, <span class="ValueType">int</span> mid, <span class="ValueType">int</span> right)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> leftCursor = left;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> rightCursor = mid;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> tmpCursor = left;     <br />&#160;&#160;&#160; TElement leftElement = data[leftCursor];     <br />&#160;&#160;&#160; TElement rightElement = data[rightCursor];     <br />&#160;&#160;&#160; <span class="InlineComment">// By never merging empty lists, we know we&#39;ll always have valid starting points</span>     <br />&#160;&#160;&#160; <span class="Statement">while</span> (<span class="Keyword">true</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// When equal, use the left element to achieve stability</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (currentComparer.Compare(leftElement, rightElement) &lt;= 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tmp[tmpCursor++] = leftElement;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; leftCursor++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (leftCursor &lt; mid)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; leftElement = data[leftCursor];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Only the right list is still active. Therefore tmpCursor must equal rightCursor,</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// so there&#39;s no point in copying the right list to tmp and back again. Just copy</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// the already-sorted bits back into data.</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Copy(tmp, left, data, left, tmpCursor - left);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; tmp[tmpCursor++] = rightElement;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; rightCursor++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (rightCursor &lt;= right)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; rightElement = data[rightCursor];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Only the left list is still active. Therefore we can copy the remainder of</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// the left list directly to the appropriate place in data, and then copy the</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// appropriate portion of tmp back.</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Copy(data, leftCursor, data, tmpCursor, mid - leftCursor);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Copy(tmp, left, data, left, tmpCursor - left);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Here, &quot;mid&quot; is the <em>exclusive</em> upper bound of the left subsection, and the <em>inclusive</em> lower bound of the right subsection... whereas &quot;right&quot; is the <em>inclusive</em> upper bound of the right subsection. Again, it&#39;s possible that this is worth tidying up at some point to be more consistent, but it&#39;s not too bad.</p>  <p>This time there&#39;s a little bit more special-casing. We take the approach that whichever sequence runs out first (which we can detect as soon as the &quot;currently advancing&quot; cursor hits its boundary), we can optimize what still has to be copied. If the &quot;left&quot; sequence runs out first, then we know the remainder of the &quot;right&quot; sequence must already be in the correct place - so all we have to do is copy as far as we&#39;ve written with tmpCursor back from the temporary array to the main array.</p>  <p>If the &quot;right&quot; sequence runs out first, then we can copy the rest of the &quot;left&quot; sequence directly into the right place (at the end of the section) and then again copy just what&#39;s needed from the temporary array back to the main array.</p>  <p>This is as fast as I&#39;ve managed to get it so far (without delving into too many of the more complicated optimizations available) - and I&#39;m reasonably pleased with it. I have no doubt that it could be improved significantly, but I didn&#39;t want to spend too much effort on it when I knew I&#39;d be adapting everything for the key projection difficulty anyway.</p>  <h3>Testing</h3>  <p>I confess I don&#39;t know the best way to test sorting algorithms. I have two sets of tests here:</p>  <ul>   <li>A new project (MergeSortTest) where I actually implemented the sort before integrating it into OrderedEnumerable </li>    <li>All my existing OrderBy (etc) tests </li> </ul>  <p>The new project also acts as a sort of benchmark - although it&#39;s pretty unscientific, and the key projection issue means the .NET implementation isn&#39;t <em>really</em> comparable with the Edulinq one at the moment. Still, it&#39;s a good indication of <em>very roughly</em> how well the implementation is doing. (It varies, interestingly enough... on my main laptop, it&#39;s about 80% slower than LINQ to Objects; on my netbook it&#39;s only about 5% slower. Odd, eh?) The new project sorts a range of sizes of input data, against a range of domain sizes (so with a small domain but a large size you&#39;re bound to get equal elements - this helps to verify stability). The values which get sorted are actually doubles, but we only sort based on the integer part - so if the input sequence is 1.3, 3.5, 6.3, 3.1 then we should get an output sequence of 1.3, 3.5, 3.1, 6.3 - the 3.5 and 3.1 are in that order due to stability, as they compare equal under the custom comparer. (I&#39;m performing the &quot;integer only&quot; part using a custom comparer, but we could equally have used OrderBy(x =&gt; (int) x)).</p>  <h3>Conclusion</h3>  <p>One problem (temporarily) down, one to go. I&#39;m afraid that the code in part 26d is likely to end up being pretty messy in terms of generics - and even then I&#39;m likely to talk about rather more options than I actually get round to coding.</p>  <p>Still, our simplistic model of OrderedEnumerable has served us well for the time being. Hopefully it&#39;s proved more useful educationally this way - I suspect that if I&#39;d dived into the final code right from the start, we&#39;d all end up with a big headache.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
