<html>
<head>
<title>Reimplementing LINQ to Objects: Part 4 - Range</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 4 - Range</h1>
<p>This will be a short post, and there&#39;ll probably be some more short ones coming up too. I think it makes sense to only cover multiple operators in a single post where they&#39;re <em>really</em> similar. (Count and LongCount spring to mind.) I&#39;m in your hands though - if you would prefer &quot;chunkier&quot; posts, please say so in the comments.</p>  <p>This post will deal with the Range generation operator.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.range.aspx" target="_blank">Range</a> only has a single signature:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; Range(     <br />&#160;&#160;&#160; <span class="ValueType">int</span> start,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count) </div>  <p>Unlike most of LINQ, this isn&#39;t an extension method - it&#39;s a plain old static method. It returns an iterable object which will yield &quot;count&quot; integers, starting from &quot;start&quot; and incrementing each time - so a call to Enumerable.Range(6, 3) would yield 6, then 7, then 8.</p>  <p>As it doesn&#39;t operate on an input sequence, there&#39;s no sense in which it could stream or buffer its input, but:</p>  <ul>   <li>The arguments need to be validated eagerly; the count can&#39;t be negative, and it can&#39;t be such that any element of the range could overflow Int32. </li>    <li>The values will be yielded lazily - Range should be <em>cheap</em>, rather than creating (say) an array of &quot;count&quot; elements and returning that. </li> </ul>  <h3>How are we going to test it?</h3>  <p>Testing a plain static method brings us a new challenge in terms of switching between the &quot;normal&quot; LINQ implementation and the Edulinq one. This is an artefact of the namespaces I&#39;m using - the tests are in Edulinq.Tests, and the implementation is in Edulinq. &quot;Parent&quot; namespaces are <em>always</em> considered when the compiler tries to find a type, and they take priority over anything in using directives - even a using directive which tries to explicitly alias a type name.</p>  <p>The (slightly ugly) solution to this that I&#39;ve chosen is to include a using directive to create an alias which couldn&#39;t otherwise be resolved - in this case, RangeClass. The using directive will either alias RangeClass to System.Linq.Enumerable or Edulinq.Enumerable. The tests then all use RangeClass.Range. I&#39;ve also changed how I&#39;m switching between implementations - I now have two project configurations, one of which defines the NORMAL_LINQ preprocessor symbol, and the other of which doesn&#39;t. The RangeTest class therefore contains:</p>  <div class="code"><span class="PreProcessorDirective">#if</span> NORMAL_LINQ     <br /><span class="Namespace">using</span> RangeClass = System.Linq.Enumerable;     <br /><span class="PreProcessorDirective">#else</span>     <br /><span class="Namespace">using</span> RangeClass = Edulinq.Enumerable;     <br /><span class="PreProcessorDirective">#endif</span> </div>  <p>There are alternatives to this approach, of course:</p>  <ul>   <li>I could move the tests to a different namespace </li>    <li>I could make the project <em>references</em> depend on the configuration... so the &quot;Normal LINQ&quot; configuration wouldn&#39;t reference the Edulinq implementation project, and the &quot;Edulinq implementation&quot; configuration wouldn&#39;t reference System.Core. I could then just use Enumerable.Range with an appropriate using directive for System.Linq conditional on the NORMAL_LINQ preprocessor directive, as per the other tests. </li> </ul>  <p>I like the idea of the second approach, but it means manually tinkering with the test project file - Visual Studio doesn&#39;t expose any way of conditionally including a reference. I may do this at a later date... thoughts welcome.</p>  <h3>What are we going to test?</h3>  <p>There isn&#39;t much we can really test for ranges - I only have eight tests, none of which are particularly exciting:</p>  <ul>   <li>A simple valid range should look right when tested with AssertSequenceEqual </li>    <li>The start value should be allowed to be negative </li>    <li>Range(Int32.MinValue, 0) is an empty range </li>    <li>Range(Int32.MaxValue, 1) yields just Int32.MaxValue</li>    <li>The count <em>can&#39;t</em> be negative </li>    <li>The count <em>can</em> be zero </li>    <li>start+count-1 can&#39;t exceed Int32.MaxValue (so Range(Int32.MaxValue, 2) isn&#39;t valid) </li>    <li>start+count-1 can <em>be</em> Int32.MaxValue (so Range(Int32.MaxValue, 1) <em>is</em> valid)</li> </ul>  <p>The last two are tested with a few different examples each - a large start and a small count, a small start and a large count, and &quot;fairly large&quot; values for both start and count.</p>  <p>Note that I <em>don&#39;t</em> have any tests for lazy evaluation - while I <em>could </em>test that the returned value doesn&#39;t implement any of the other collection interfaces, it would be a little odd to do so. On the other hand, we <em>do</em> have tests which have an enormous count - such that anything which really tried to allocate a collection of that size would almost certainly fail...</p>  <h3>Let&#39;s implement it!</h3>  <p>It will surely be no surprise by now that we&#39;re going to use a split implementation, with a public method which performs argument validation eagerly and then uses a private method with an iterator block to perform the actual iteration.</p>  <p>Having validated the arguments, we know that we&#39;ll never overflow the bounds of Int32, so we can be pretty casual in the main part of the implementation.</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; Range(<span class="ValueType">int</span> start, <span class="ValueType">int</span> count)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (count &lt; 0)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentOutOfRangeException(<span class="String">&quot;count&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="InlineComment">// Convert everything to long to avoid overflows. There are other ways of checking</span>    <br />&#160;&#160;&#160; <span class="InlineComment">// for overflow, but this way make the code correct in the most obvious way.</span>    <br />&#160;&#160;&#160; <span class="Statement">if</span> ((<span class="ValueType">long</span>)start + (<span class="ValueType">long</span>)count - 1L &gt; <span class="ValueType">int</span>.MaxValue)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentOutOfRangeException(<span class="String">&quot;count&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> RangeImpl(start, count);    <br />}    <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; RangeImpl(<span class="ValueType">int</span> start, <span class="ValueType">int</span> count)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; count; i++)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> start + i;    <br />&#160;&#160;&#160; }    <br />} </div>  <p>Just a few points to note here:</p>  <ul>   <li>Arguably it&#39;s the <em>combination</em> of &quot;start&quot; and &quot;count&quot; which is invalid in the second check, rather than just count. It would possibly be nice to allow ArgumentOutOfRangeException (or ArgumentException in general) to blame multiple arguments rather than just one. However, using &quot;count&quot; here matches the framework implementation.</li>    <li>There are other ways of performing the second check, and I certainly didn&#39;t have to make <em>all</em> the operands in the expression longs. However, I think this is the simplest code which is clearly correct based on the documentation. I don&#39;t need to think about all kinds of different situations and check that they all work. The arithmetic will clearly be valid when using the Int64 range of values, so I don&#39;t need to worry about overflow, and I don&#39;t need to consider whether to use a checked or unchecked context.</li>    <li>There are also other ways of looping in the private iterator block method, but I think this is the simplest. Another obvious and easy alternative is to keep two values, one for the count of yielded values and the other for the next value to yield, and increment them both on each iteration. A more complex approach would be to use just one loop variable - but you can&#39;t use &quot;value &lt; start + count&quot; in case the final value is exactly Int32.MaxValue, and you can&#39;t use &quot;value &lt;= start + count - 1&quot; in case the arguments are (int.MinValue, 0). Rather than consider all the border cases, I&#39;ve gone for an obviously-correct solution. If you really, really cared about the performance of Range, you&#39;d want to investigate various other options.</li> </ul>  <p>Prior to writing up this post, I didn&#39;t have good tests for Range(Int32.MaxValue, 1) and Range(Int32.MinValue, 0)... but as they could easily go wrong as mentioned above, I&#39;ve now included them. I find it interesting how considering alternative implementations suggests extra tests.</p>  <h3>Conclusion</h3>  <p>&quot;Range&quot; was a useful method to implement in order to test some other operators - &quot;Count&quot; in particular. Now that I&#39;ve started on the non-extension methods though, I might as well do the other two (Empty and Repeat). I&#39;ve already implemented &quot;Empty&quot;, and will hopefully be able to write it up today. &quot;Repeat&quot; shouldn&#39;t take much longer, and then we can move on to &quot;Count&quot; and &quot;LongCount&quot;.</p>  <p>I think this code is a good example of situations where it&#39;s worth writing &quot;dumb&quot; code which looks like the documentation, rather than trying to write possibly shorter, possibly slightly more efficient code which is harder to think about. No doubt there&#39;ll be more of that in later posts...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
