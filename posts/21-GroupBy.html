<html>
<head>
<title>Reimplementing LINQ to Objects: Part 21 - GroupBy</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 21 - GroupBy</h1>
<p>Okay, after the brief hiatus earlier, we&#39;re ready to group sequences.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx">GroupBy</a> has eight overloads, using up to four type parameters and up to five normal parameters. Those of a sensitive disposition may wish to turn away now:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer) </div>  <p>Okay, you can look back now. All the nastiness will go away soon, I promise. You see, this is yet another operator with overloads which effectively fill in defaults... although there&#39;s a twist here. Here are the various parameters and their meanings:</p>  <ul>   <li>source: the input sequence, as ever, of element type TSource. </li>    <li>keySelector: a delegate to apply to each element in the input sequence to obtain a key (type TKey). The key is what decides which group the element is associated with. </li>    <li>elementSelector (optional): a delegate to apply to each element (type TElement) to obtain the value which should be part of the relevant group. If it&#39;s not present, you can think of it as being the identity conversion. </li>    <li>resultSelector (optional): a delegate to apply to each grouping to produce a final result (type TResult). See below for the difference between overloads which specify this and those which don&#39;t. </li>    <li>comparer (optional): an equality comparer used to compare keys; groups are formed by equal keys. If unspecified or null, the default equality comparer for TKey is used. </li> </ul>  <p>Now, there&#39;s only one tricky bit here: resultSelector. In overloads where this is present, the result is type IEnumerable&lt;TResult&gt;; otherwise it&#39;s IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;. That would make perfect sense <em>if</em> the type of resultSelector were Func&lt;IGrouping&lt;TKey, TElement&gt;, TResult&gt; - that would just make it effectively default to an identity conversion. However, the type is <em>actually</em> Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt;. There&#39;s not a lot of difference between the two logically: basically you&#39;ve got a key and a sequence of elements in both cases - but the disparity reduces the elegance of both the design and the implementation in my view. In fact, it&#39;s not <em>wholly</em> clear to me why the overloads with a resultSelector are required in the first place - you&#39;ll see why later.</p>  <p>Anyway, the basic operation should be reasonably familiar by now. We&#39;re going to look at each input value in turn, and map it to a key and a group element. We&#39;ll usually return a sequence of groups, where each group consists of the elements produced by input values with an equal key. If we&#39;ve specified a resultSelector, that delegate will be presented with each key and all the members of the group associated with that key, and the final result sequence will consist of the return values of the delegate.</p>  <p>General behaviour:</p>  <ul>   <li>The operator is implemented with deferred execution, but it&#39;s not as deferred as some other operators. More below. </li>    <li>All arguments other than comparer must not be null; this is validated eagerly. </li>    <li>The source is read completely as soon as you start iterating over the results. </li> </ul>  <p>Basically this performs exactly the same steps as ToLookup, except:</p>  <ul>   <li>GroupBy uses deferred execution. Aside from anything else, this means that if you change the contents of &quot;source&quot; later and iterate over the results again, you&#39;ll see the changes (whereas the lookup returned by ToLookup is effectively independent of the source) </li>    <li>The return value is always a sequence (whether it&#39;s a sequence of groups or the result of calling resultSelector). This means you can&#39;t perform arbitrary lookups on it later. </li> </ul>  <p>I&#39;ve already quoted from the documentation when it comes to the ordering of the groups and the elements within the groups, but for completeness, here it is again:</p>  <blockquote>   <p>The IGrouping&lt;TKey, TElement&gt; objects are yielded in an order based on the order of the elements in source that produced the first key of each IGrouping&lt;TKey, TElement&gt;. Elements in a grouping are yielded in the order they appear in source.</p> </blockquote>  <p>When a resultSelector is present, the last sentence should be reinterpreted to consider the IEnumerable&lt;TElement&gt; sequence presented to resultSelector.</p>  <h3>What are we going to test?</h3>  <p>First let&#39;s talk about deferred execution. GroupBy <em>does</em> use deferred execution - but that it&#39;s not as deferred as usual. For most operators (such as Select) you can call GetEnumerator() on the result and it still won&#39;t actually start iterating over the input sequence until you call MoveNext() on the result&#39;s iterator. In GroupBy - at least in the &quot;proper&quot; implementation - it&#39;s the call to GetEnumerator() that does all the work.</p>  <p>In other words, my usual test like this wouldn&#39;t work:</p>  <div class="code"><span class="InlineComment">// This won&#39;t work for GroupBy in LINQ to Objects</span>     <br /><span class="Namespace">using</span> (<span class="Keyword">new</span> ThrowingEnumerable().GroupBy(x =&gt; x).GetEnumerator())     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// No exception</span>     <br />} </div>  <p>In fact, I would probably argue that on reflection, my existing tests which check that execution is deferred until the first call to MoveNext() are probably overzealous. For GroupBy, the tests are relatively liberal - they will work whether it&#39;s GetEnumerator() or MoveNext() which starts iterating over the input sequence. This is handy, as my implementation is currently slightly more deferred than that of LINQ to Objects :) Here are the relevant tests:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> ExecutionIsPartiallyDeferred()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// No exception yet...</span>     <br />&#160;&#160;&#160; <span class="Keyword">new</span> ThrowingEnumerable().GroupBy(x =&gt; x);     <br />&#160;&#160;&#160; <span class="InlineComment">// Note that for LINQ to Objects, calling GetEnumerator() starts iterating</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// over the input sequence, so we&#39;re not testing that...</span>     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SequenceIsReadFullyBeforeFirstResultReturned()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };     <br />&#160;&#160;&#160; <span class="InlineComment">// Final projection will throw</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = numbers.Select(x =&gt; 10 / x);     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> groups = query.GroupBy(x =&gt; x);     <br />&#160;&#160;&#160; Assert.Throws&lt;DivideByZeroException&gt;(() =&gt;     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = groups.GetEnumerator())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; });     <br />} </div>  <p>I also have one test for each of the four overloads which doesn&#39;t specify a comparer. I haven&#39;t got any tests to ensure that the comparer is used properly - I felt they would be more effort than they were worth.</p>  <p>Here&#39;s the test for the most complicated overload, just to show how all the bits fit together:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> GroupByWithElementProjectionAndCollectionProjection()     <br />{     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] source = { <span class="String">&quot;abc&quot;</span>, <span class="String">&quot;hello&quot;</span>, <span class="String">&quot;def&quot;</span>, <span class="String">&quot;there&quot;</span>, <span class="String">&quot;four&quot;</span> };     <br />&#160;&#160;&#160; <span class="InlineComment">// This time &quot;values&quot; will be an IEnumerable&lt;char&gt;, the first character of each</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// source string contributing to the group</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> groups = source.GroupBy(x =&gt; x.Length,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; x =&gt; x[0],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (key, values) =&gt; key + <span class="String">&quot;:&quot;</span> + <span class="ReferenceType">string</span>.Join(<span class="String">&quot;;&quot;</span>, values));     <br />    <br />&#160;&#160;&#160; groups.AssertSequenceEqual(<span class="String">&quot;3:a;d&quot;</span>, <span class="String">&quot;5:h;t&quot;</span>, <span class="String">&quot;4:f&quot;</span>);     <br />} </div>  <p>Let&#39;s look at the parameters involved:</p>  <ul>   <li>source: just an array of strings </li>    <li>keySelector: takes a string and maps it to its length. We will end up with three groups, as we have strings of length 3 (&quot;abc&quot; and &quot;def&quot;), 5 (&quot;hello&quot; and &quot;there&quot;) and 4 (&quot;four&quot;) </li>    <li>elementSelector: takes a string and maps it to its first character. </li>    <li>resultSelector: takes a key (the length) and a sequence of elements (the first characters of all the input strings of that length) and returns a string joining them all together </li> </ul>  <p>So the result for the first group is &quot;3:a;d&quot; - 3 is the key, &#39;a&#39; and &#39;d&#39; are the first letters of &quot;abc&quot; and &quot;def&quot;, and they&#39;re joined together according to the resultSelector.</p>  <p>Finally, I also have a test demonstrating the use of GroupBy in a query expression, showing that these two queries are equivalent:</p>  <div class="code"><span class="ReferenceType">string</span>[] source = { <span class="String">&quot;abc&quot;</span>, <span class="String">&quot;hello&quot;</span>, <span class="String">&quot;def&quot;</span>, <span class="String">&quot;there&quot;</span>, <span class="String">&quot;four&quot;</span> };     <br />    <br /><span class="Linq">var</span> query1 = source.GroupBy(x =&gt; x.Length, x =&gt; x[0]);     <br />    <br /><span class="Linq">var</span> query2 = <span class="Linq">from</span> x <span class="Statement">in</span> source     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">group</span> x[0] <span class="Linq">by</span> x.Length; </div>  <p>Okay, enough of the tests... what about the real code?</p>  <h3>Let&#39;s implement it!</h3>  <p>First, some interesting line counts:</p>  <ul>   <li>Lines in public method signatures: 36 </li>    <li>Lines implementing argument validation: 16 </li>    <li>Lines <em>just</em> delegating from one public overload to another: 6 </li>    <li>Lines of actual implementation: 7 </li> </ul>  <p>Sad, isn&#39;t it? Still, there are things worth talking about.</p>  <p>Firstly, let&#39;s reduce the eight overloads to two: the two that both have elementSelector and comparer specified. The six overloads which miss one or other of those parameters can simply be implemented by providing an identity conversion or the default key comparer. So that leaves us with this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)</div>  <p>Now <em>normally</em> I like to implement a method with fewer parameters by calling one with <em>more</em> parameters... but there&#39;s a slight problem in this case. We would have to provide a resultSelector which took a key and a sequence of elements, and creating a grouping from it. We <em>could</em> do that just by reusing our Grouping class... but there seems little reason to do that. In particular, suppose we implement it the other way round: given a grouping, we can easily extract the key (via the Key property) and the grouping itself is a sequence of the elements. In other words, we can implement the more complex method in terms of the simpler one:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (resultSelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;resultSelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// Let the other GroupBy overload do the rest of the argument validation</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.GroupBy(keySelector, elementSelector, comparer)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(<span class="Linq">group</span> =&gt; resultSelector(<span class="Linq">group</span>.Key, <span class="Linq">group</span>));     <br />} </div>  <p>The difference may seem somewhat arbitrary to start with, until we provide the final overload that we&#39;re delegating to. Surprise surprise, we can use ToLookup yet again:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (elementSelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;elementSelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> GroupByImpl(source, keySelector, elementSelector, comparer ?? EqualityComparer&lt;TKey&gt;.Default);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupByImpl&lt;TSource, TKey, TElement&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; Func&lt;TSource, TElement&gt; elementSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = source.ToLookup(keySelector, elementSelector, comparer);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="Linq">var</span> result <span class="Statement">in</span> lookup)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> result;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>You see, ILookup&lt;TKey, TElement&gt; already implements IEnumerable&lt;IGrouping&lt;TKey, TValue&gt;&gt; so we have no extra work to do. If we had implemented the two overloads the other way round by calling &quot;new Grouping(key, sequence)&quot; as a resultSelector, we&#39;d have ended up with two &quot;wrapper&quot; layers of Grouping when we only need one. (Alternatively, we could have cast straight back to IGrouping, but that would have felt somewhat wrong, as well as requiring an execution-time check.)</p>  <p>Note that again, we could have used &quot;yield foreach&quot; to great effect if it had been available...</p>  <p>Now do you see why I believe this would have been more elegant if the type of resultSelector had been Func&lt;IGrouping&lt;TKey, TElement&gt;, TResult&gt; instead? That way we could have just treated resultSelector as another optional parameter with a &quot;default&quot; value of the identity conversion... and all 7 simpler overloads could have delegated straight to the most complex one. Oh well.</p>  <h3>Conclusion</h3>  <p>Now we&#39;ve done &quot;Join&quot; and &quot;GroupBy&quot;, there&#39;s another very obvious operator to implement: GroupJoin. This (in conjunction with DefaultIfEmpty) is how the effect of left joins are usually achieved in LINQ. Let&#39;s see if ToLookup does what we need yet again...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
