<html>
<head>
<title>Reimplementing LINQ to Objects: Part 28 - Sum</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 28 - Sum</h1>
<p>Okay, I&#39;ve bitten the bullet. The first of the four Aggregation Operators Of Overload Doom (AOOOD) that I&#39;ve implemented is Sum. It was far from <em>difficult</em> to implement - just tedious.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.sum.aspx">Sum</a> has 20 overloads - a set of 4 for each of the types that it covers (int, long, float, double, decimal). Here are the overloads for int:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Sum(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Sum(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Sum&lt;T&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;T&gt; source,     <br />&#160;&#160;&#160; Func&lt;T, <span class="ValueType">int</span>&gt; selector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Sum&lt;T&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;T&gt; source,     <br />&#160;&#160;&#160; Func&lt;T, <span class="ValueType">int</span>?&gt; selector) </div>  <p>As you can see, there are basically two variations:</p>  <ul>   <li>A source of the numeric type itself, or a source of an arbitrary type with a projection to the numeric type </li>    <li>The numeric type can be nullable or non-nullable </li> </ul>  <p>The behaviour is as follows:</p>  <ul>   <li>All overloads use <em>immediate execution</em>: it will immediately iterate over the source sequence to compute the sum, which is obviously the return value. </li>    <li>source and selector must both be non-null </li>    <li>Where there&#39;s a selector, the operator is equivalent to source.Select(selector).Sum() - or you can think of the versions <em>without</em> a selector as using an identity selector </li>    <li>Where the numeric type is nullable, null values are ignored </li>    <li>The sum of an empty sequence is 0 (even for nullable numeric types) </li> </ul>  <p>The last point is interesting - because the overloads with nullable numeric types <em>never return a null value</em>. Initially I missed the fact that the return type even <em>was</em> nullable. I think it&#39;s somewhat misleading to be nullable but never null - you might have at least expected that the return value for an empty sequence (or one consisting only of null values) would be null.</p>  <p>For int, long and decimal, overflow within the sum will throw OverflowException. For single and double, the result will be positive or negative infinity. If the sequence contains a &quot;not-a-number&quot; value (NaN), the result will be NaN too.</p>  <h3>What are we going to test?</h3>  <p>A lot!</p>  <p>In total, I have 123 tests across the five types. The tests are mostly the same for each type, with the exception of overflow behaviour and not-a-number behaviour for single and double. Each overload is tested reasonably thoroughly:</p>  <ul>   <li>Argument validation </li>    <li>Summing a simple sequence </li>    <li>Summing an empty sequence </li>    <li>(Nullable) Summing a simple sequence containing null values </li>    <li>(Nullable) Summing a sequence containing only null values </li>    <li>Positive overflow (either to an exception or infinity) </li>    <li>Negative overflow (only one test per type, rather than for each overload) </li>    <li>(Single/Double) Sequences containing NaN values </li>    <li>Projections resulting in all of the above </li> </ul>  <p>Most of this was done using cut and paste, leading to a 916-line source file. On Twitter, followers have suggested a couple of alternatives - templating (possibly for both the tests and the implementation), or using more advanced features of unit test frameworks. There&#39;s nothing wrong with these suggestions - but I&#39;m always concerned about the balance within an elegant-but-complex solution to repetition. If it takes longer to get to the &quot;neat&quot; solution, and then each individual test is harder to read, is it worth it? It certainly makes it easier to add one test which is then applicable over several types, or to modify all &quot;copies&quot; of an existing test - but equally it makes it harder to make variations (such as overflow) fit within the pattern. I have no quarrel with the idea of using more advanced techniques here, but I&#39;ve stuck to a primitive approach for the moment.</p>  <h3>Let&#39;s implement it!</h3>  <p>Again, I&#39;ll only demonstrate the &quot;int&quot; implementations - but talk about single/double later on. There are plenty of ways I <em>could</em> have implemented this:</p>  <ul>   <li>Delegate everything to the <em>simplest</em> overload using &quot;Where&quot; for the nullable sequences and &quot;Select&quot; for the projection sequences </li>    <li>Delegate everything to the most <em>complex</em> overload using identity projections </li>    <li>Implement each method independently </li>    <li>Somewhere in-between :) </li> </ul>  <p>In the end I&#39;ve implemented each non-projecting overload by delegating to the corresponding projection-based one with an identity projection. I&#39;ve implemented the non-nullable and nullable versions separately though. Here&#39;s the complete implementation:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Sum(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> Sum(source, x =&gt; x);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Sum(<span class="Keyword">this</span> IEnumerable&lt;<span class="ValueType">int</span>?&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> Sum(source, x =&gt; x);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span> Sum&lt;T&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;T&gt; source,     <br />&#160;&#160;&#160; Func&lt;T, <span class="ValueType">int</span>&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (selector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;selector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> sum = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (T item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sum += selector(item);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> sum;     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">int</span>? Sum&lt;T&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;T&gt; source,     <br />&#160;&#160;&#160; Func&lt;T, <span class="ValueType">int</span>?&gt; selector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (selector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;selector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">checked</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> sum = 0;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (T item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sum += selector(item).GetValueOrDefault();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> sum;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Note the use of <a href="http://msdn.microsoft.com/en-us/library/72cec0e0.aspx">Nullable&lt;T&gt;.GetValueOrDefault()</a> to &quot;ignore&quot; null values - it felt easier to add zero than to use an &quot;if&quot; block here. I <em>suspect</em> it&#39;s also more efficient, as there&#39;s no need for any conditionality here: I&#39;d expect the implementation of GetValueOrDefault() to just return the underlying &quot;value&quot; field within the Nullable&lt;T&gt;, without performing the check for HasValue which the Value property normally would.</p>  <p>Of course, if I were <em>really</em> bothered by performance I&#39;d implement each operation separately, instead of using the identity projection.</p>  <p>Note the use of the &quot;checked&quot; block to make sure that overflow is handled appropriately. As I&#39;ve mentioned before, it would quite possibly be a good idea to turn overflow checking on for the whole assembly, but here I feel it&#39;s worth making it explicit to show that we consider overflow as an important part of the behaviour of this operator. The single/double overloads <em>don&#39;t</em> use checked blocks, as their overflow behaviour isn&#39;t affected by the checked context.</p>  <h3>Conclusion</h3>  <p>One down, three to go! I suspect Min and Max will use even more cutting and pasting (with judiciously applied changes, of course). There are 22 overloads for each of those operators, due to the possibility of using an arbitrary type - but I may well be able to use the most generic form to implement <em>all</em> the numeric versions. I may measure the impact this has on performance before deciding for sure. Anyway, that&#39;s a topic for the next post...</p>  <h3>Addendum</h3>  <p>As has been pointed out in the comments, my original implementation used a float to accumulate values when summing a sequence of floats. This causes problems, as these two new tests demonstrate:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> NonOverflowOfComputableSumSingle()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">float</span>[] source = { <span class="ValueType">float</span>.MaxValue, <span class="ValueType">float</span>.MaxValue,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; -<span class="ValueType">float</span>.MaxValue, -<span class="ValueType">float</span>.MaxValue };     <br />&#160;&#160;&#160; <span class="InlineComment">// In a world where we summed using a float accumulator, the</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// result would be infinity.</span>     <br />&#160;&#160;&#160; Assert.AreEqual(0f, source.Sum());     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> AccumulatorAccuracyForSingle()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// 20000000 and 20000004 are both exactly representable as</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// float values, but 20000001 is not. Therefore if we use</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// a float accumulator, we&#39;ll end up with 20000000. However,</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// if we use a double accumulator, we&#39;ll get the right value.</span>     <br />&#160;&#160;&#160; <span class="ValueType">float</span>[] array = { 20000000f, 1f, 1f, 1f, 1f };     <br />&#160;&#160;&#160; Assert.AreEqual(20000004f, array.Sum());     <br />} </div>  <p>The second of these tests is specific to floating point arithmetic - there&#39;s no equivalent in the integer domain. Hopefully the comment makes the test clear. We could still do better if we used the <a href="http://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>, but I haven&#39;t implemented that yet, and don&#39;t currently intend to. Worth noting as a potential follow-on project though.</p>  <p>Back to the first test though: this certainly <em>can</em> be represented in integers. If we try to sum { int.MaxValue, int.MaxValue, -int.MaxValue, -int.MaxValue } there are two options: we can overflow (throwing an exception) or we can return 0. If we use a long accumulator, we&#39;ll return 0. If we use an int accumulator, we&#39;ll overflow. I genuinely didn&#39;t know what the result for LINQ to Objects would be until I tried it - and found that it overflows. I&#39;ve added a test to document this behaviour:</p>  <div class="code">[Test]   <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> OverflowOfComputableSumInt32()    <br />{    <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { <span class="ValueType">int</span>.MaxValue, 1, -1, -<span class="ValueType">int</span>.MaxValue };    <br />&#160;&#160;&#160; <span class="InlineComment">// In a world where we summed using a long accumulator, the</span>    <br />&#160;&#160;&#160; <span class="InlineComment">// result would be 0.</span>    <br />&#160;&#160;&#160; Assert.Throws&lt;OverflowException&gt;(() =&gt; source.Sum());    <br />} </div>  <p>Of course, I could have gone my own way and made Edulinq more capable than LINQ to Objects here, but in this case I&#39;ve gone with the existing behaviour.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
