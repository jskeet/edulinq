<html>
<head>
<title>Reimplementing LINQ to Objects: Part 16 - Intersect (and build fiddling)</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 16 - Intersect (and build fiddling)</h1>
<p>Okay, this is more like it - after the dullness of Union, Intersect has a new pattern to offer... and one which we&#39;ll come across repeatedly.</p>  <p>First, however, I should explain some more changes I&#39;ve made to the solution structure...</p>  <h3>Building the test assembly</h3>  <p>I&#39;ve just had an irritating time sorting out something I thought I&#39;d fixed this afternoon. Fed up of accidentally testing against the wrong implementation, my two project configurations (&quot;Normal LINQ&quot; and &quot;Edulinq implementation&quot;) now target different libraries from the test project: only the &quot;Normal LINQ&quot; configuration refers to System.Core, and only the &quot;Edulinq implementation&quot; configuration refers to the Edulinq project itself. Or so I thought. Unfortunately, msbuild automatically adds System.Core in unless you&#39;re careful. I had to add this into the &quot;Edulinq implementation&quot; property group part of my project file to avoid accidentally pulling in System.Core:</p>  <div class="code"><span class="Element">&lt;AddAdditionalExplicitAssemblyReferences&gt;</span>false<span class="Element">&lt;/AddAdditionalExplicitAssemblyReferences&gt;</span> </div>  <p>Unfortunately, at that point all the extension methods I&#39;d written within the tests project - and the references to HashSet&lt;T&gt; - failed. I should have noticed them <em>not</em> failing before, and been suspicious. Hey ho.</p>  <p>Now I&#39;m aware that you can add your own version of <a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.extensionattribute.aspx" target="_blank">ExtensionAttribute</a>, but I believe that can become a problem if at execution time you <em>do</em> actually load System.Core... which I will end up doing, as the Edulinq assembly itself references it (for HashSet&lt;T&gt; aside from anything else).</p>  <p>There may well be multiple solutions to this problem, but I&#39;ve come up with one which appears to work:</p>  <ul>   <li>Add an Edulinq.TestSupport project, and refer to that from both configurations of Edulinq.Tests </li>    <li>Make Edulinq.TestSupport refer to System.Core so it can use whatever collections it likes, as well as extension methods </li>    <li>Put all the non-test classes (those containing extension methods, and the weird and wonderful collections) into the Edulinq.TestSupport project. </li>    <li>Add a DummyClass to Edulinq.TestSupport in the namespace System.Linq, so that using directives within Edulinq.Tests don&#39;t need to be conditionalized </li> </ul>  <p>All seems to be working now - and finally, if I try to refer to an extension method I haven&#39;t implemented in Edulinq yet, it will fail to compile instead of silently using the System.Core one. Phew. Now, back to Intersect...</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.intersect.aspx" target="_blank">Intersect</a> has a now-familiar pair of overloads:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer) </div>  <p>Fairly obviously, it computes the <em>intersection</em> of two sequences: the elements that occur in both &quot;first&quot; and &quot;second&quot;. Points to note:</p>  <ul>   <li>Again, the first overload uses the default equality comparer for TSource, and the second overload does if you pass in &quot;null&quot; as the comparer, too. </li>    <li>Neither &quot;first&quot; nor &quot;second&quot; can be null </li>    <li>The method <em>does</em> use deferred execution - but in a way which may seem unusual at first sight </li>    <li>The result sequence only contains distinct elements - even if an element occurs multiple times in both input sequences, it will only occur once in the result </li> </ul>  <p>Now for the interesting bit - exactly when the two sequences are used. MSDN claims this:</p>  <blockquote>   <p>When the object returned by this method is enumerated, Intersect enumerates first, collecting all distinct elements of that sequence. It then enumerates second, marking those elements that occur in both sequences. Finally, the marked elements are yielded in the order in which they were collected.</p> </blockquote>  <p>This is demonstrably incorrect. Indeed, I have a test which would fail under LINQ to Objects if this were the case. What <em>actually</em> happens is this:</p>  <ul>   <li>Nothing happens until the first result element is requested. I know I&#39;ve said so already, but it&#39;s worth repeating. </li>    <li>As soon as the first element of the result is requested, the <em>whole</em> of the &quot;second&quot; input sequence is read, as well as the first (and possibly more) elements of the &quot;first&quot; input sequence - enough to return the first result, basically. </li>    <li>Results are read from the &quot;first&quot; input sequence <em>as and when they are required</em>. Only elements which were originally in the &quot;second&quot; input sequence and haven&#39;t already been yielded are returned. </li> </ul>  <p>We&#39;ll see this pattern of &quot;greedily read the second sequence, but stream the first sequence&quot; again when we look at Join... but let&#39;s get back to the tests.</p>  <h3>What are we going to test?</h3>  <p>Obviously I&#39;ve got simple tests including:</p>  <ul>   <li>Argument validation </li>    <li>Elements which occur multiple times in each sequence </li>    <li>The overload without a comparer specified </li>    <li>Specifying a null comparer </li>    <li>Specifying a &quot;custom&quot; comparer (I&#39;m using the case-insensitive string comparer again; news at 11) </li> </ul>  <p>However, the interesting tests are the ones which show how the sequences are actually consumed. Here they are:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> NoSequencesUsedBeforeIteration()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> first = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; <span class="Linq">var</span> second = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; <span class="InlineComment">// No exceptions!</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = first.Union(second);     <br />&#160;&#160;&#160; <span class="InlineComment">// Still no exceptions... we&#39;re not calling MoveNext.</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160; }     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SecondSequenceReadFullyOnFirstResultIteration()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] first = { 1 };     <br />&#160;&#160;&#160; <span class="Linq">var</span> secondQuery = <span class="Keyword">new</span>[] { 10, 2, 0 }.Select(x =&gt; 10 / x);     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = first.Intersect(secondQuery);     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.Throws&lt;DivideByZeroException&gt;(() =&gt; iterator.MoveNext());     <br />&#160;&#160;&#160; }     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> FirstSequenceOnlyReadAsResultsAreRead()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> firstQuery = <span class="Keyword">new</span>[] { 10, 2, 0, 2 }.Select(x =&gt; 10 / x);     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] second = { 1 };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = firstQuery.Intersect(second);     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// We can get the first value with no problems</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.IsTrue(iterator.MoveNext());     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(1, iterator.Current);     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Getting at the *second* value of the result sequence requires</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// reading from the first input sequence until the &quot;bad&quot; division</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.Throws&lt;DivideByZeroException&gt;(() =&gt; iterator.MoveNext());     <br />&#160;&#160;&#160; }     <br />} </div>  <p>The first test just proves that execution really is deferred. That&#39;s straightforward.</p>  <p>The second test proves that the &quot;second&quot; input sequence is completely read as soon as we ask for our first result. If the operator had <em>really</em> read &quot;first&quot; and then started reading &quot;second&quot;, it could have yielded the first result (1) without throwing an exception... but it didn&#39;t.</p>  <p>The third test proves that the &quot;first&quot; input sequence <em>isn&#39;t</em> read in its entirety before we start returning results. We manage to read the first result with no problems - it&#39;s only when we ask for the second result that we get an exception.</p>  <h3>Let&#39;s implement it!</h3>  <p>I have chosen to implement the same behaviour as LINQ to Objects rather than the behaviour described by MSDN, because it makes more sense to me. In general, the &quot;first&quot; sequence is given more importance than the &quot;second&quot; sequence in LINQ: it&#39;s generally the one which is streamed, with the second sequence being buffered if necessary.</p>  <p>Let&#39;s start off with the comparer-free overload - as before, it will just call the other one:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> Intersect(first, second, EqualityComparer&lt;TSource&gt;.Default);     <br />} </div>  <p>Now for the more interesting part. Obviously we&#39;ll have an argument-validating method, but what should we do in the guts? I find the duality between this and Distinct fascinating: there, we started with an empty set of elements, and tried to <em>add</em> each source element to it, yielding the element if we successfully added it (meaning it wasn&#39;t there before).</p>  <p>This time, we&#39;ve effectively got a limited set of elements which we <em>can</em> yield, but we only want to yield each of them once - so as we see items, we can <em>remove</em> them from the set, yielding only if that operation was successful. The initial set is formed from the &quot;second&quot; input sequence, and then we just iterate over the &quot;first&quot; input sequence, removing and yielding appropriately:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="Statement">if</span> (first == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;first&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">if</span> (second == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;second&quot;</span>);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> IntersectImpl(first, second, comparer ?? EqualityComparer&lt;TSource&gt;.Default);    <br />}    <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; IntersectImpl&lt;TSource&gt;(    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; first,    <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{    <br />&#160;&#160;&#160; HashSet&lt;TSource&gt; potentialElements = <span class="Keyword">new</span> HashSet&lt;TSource&gt;(second, comparer);    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> first)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (potentialElements.Remove(item))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />} </div>  <p>Next time we&#39;ll see a cross between the two techniques.</p>  <p>Ta-da - it all works as expected. I don&#39;t know whether this is how Intersect really works in LINQ to Objects, but I expect it does something remarkably similar.</p>  <h3>Conclusion</h3>  <p>After suffering from some bugs earlier today where my implementation didn&#39;t follow the documentation, it&#39;s nice to find some documentation which doesn&#39;t follow the real implementation :)</p>  <p>Seriously though, there&#39;s an efficiency point to be noted here. If you have two sequences, one long and one short, then it&#39;s much more efficient (mostly in terms of space) to use longSequence.Intersect(shortSequence) than shortSequence.Intersect(longSequence). The latter will require the whole of the long sequence to be in memory at once.</p>  <p>Next up - and I <em>might</em> just manage it tonight - our final set operator, Except.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
